fix curl types; curl_easy_setopt parameter for CURLINFO_REDIRECT_COUNT
should be a pointer to long

see https://curl.se/libcurl/c/curl_easy_setopt.html

Index: plugins/check_curl.c
--- plugins/check_curl.c.orig
+++ plugins/check_curl.c
@@ -92,16 +92,16 @@ typedef struct {
 static check_curl_config_wrapper process_arguments(int /*argc*/, char ** /*argv*/);
 
 static mp_subcheck check_http(check_curl_config /*config*/, check_curl_working_state workingState,
-							  int redir_depth);
+							  long redir_depth);
 
 typedef struct {
-	int redir_depth;
+	long redir_depth;
 	check_curl_working_state working_state;
 	int error_code;
 	check_curl_global_state curl_state;
 } redir_wrapper;
 static redir_wrapper redir(curlhelp_write_curlbuf * /*header_buf*/, check_curl_config /*config*/,
-						   int redir_depth, check_curl_working_state working_state);
+						   long redir_depth, check_curl_working_state working_state);
 
 static void print_help(void);
 void print_usage(void);
@@ -198,7 +198,7 @@ CURLcode sslctxfun(CURL *curl, SSL_CTX *sslctx, void *
 #endif     /* HAVE_SSL */
 
 mp_subcheck check_http(const check_curl_config config, check_curl_working_state workingState,
-					   int redir_depth) {
+					   long redir_depth) {
 
 	// =======================
 	// Initialisation for curl
@@ -441,19 +441,19 @@ mp_subcheck check_http(const check_curl_config config,
 						"CURLINFO_REDIRECT_COUNT");
 
 					if (verbose >= 2) {
-						printf(_("* curl LIBINFO_REDIRECT_COUNT is %d\n"), redir_depth);
+						printf(_("* curl LIBINFO_REDIRECT_COUNT is %ld\n"), redir_depth);
 					}
 
 					mp_subcheck sc_redir_depth = mp_subcheck_init();
 					if (redir_depth > config.max_depth) {
 						xasprintf(&sc_redir_depth.output,
-								  "maximum redirection depth %d exceeded in libcurl",
+								  "maximum redirection depth %ld exceeded in libcurl",
 								  config.max_depth);
 						sc_redir_depth = mp_set_subcheck_state(sc_redir_depth, STATE_CRITICAL);
 						mp_add_subcheck_to_subcheck(&sc_result, sc_redir_depth);
 						return sc_result;
 					}
-					xasprintf(&sc_redir_depth.output, "redirection depth %d (of a maximum %d)",
+					xasprintf(&sc_redir_depth.output, "redirection depth %ld (of a maximum %ld)",
 							  redir_depth, config.max_depth);
 					mp_add_subcheck_to_subcheck(&sc_result, sc_redir_depth);
 
@@ -653,7 +653,7 @@ char *uri_string(const UriTextRangeA range, char *buf,
 }
 
 redir_wrapper redir(curlhelp_write_curlbuf *header_buf, const check_curl_config config,
-					int redir_depth, check_curl_working_state working_state) {
+					long redir_depth, check_curl_working_state working_state) {
 	curlhelp_statusline status_line;
 	struct phr_header headers[255];
 	size_t msglen;
@@ -678,7 +678,7 @@ redir_wrapper redir(curlhelp_write_curlbuf *header_buf
 	}
 
 	if (++redir_depth > config.max_depth) {
-		die(STATE_WARNING, _("HTTP WARNING - maximum redirection depth %d exceeded - %s\n"),
+		die(STATE_WARNING, _("HTTP WARNING - maximum redirection depth %ld exceeded - %s\n"),
 			config.max_depth, location);
 	}
 
@@ -1400,7 +1400,7 @@ check_curl_config_wrapper process_arguments(int argc, 
 		}
 #endif /* LIBCURL_VERSION_NUM >= MAKE_LIBCURL_VERSION(7, 54, 0) */
 		if (verbose >= 2) {
-			printf(_("* Set SSL/TLS version to %d\n"), result.config.curl_config.ssl_version);
+			printf(_("* Set SSL/TLS version to %ld\n"), result.config.curl_config.ssl_version);
 		}
 		if (!specify_port) {
 			result.config.initial_config.serverPort = HTTPS_PORT;
