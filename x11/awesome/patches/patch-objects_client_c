$OpenBSD: patch-objects_client_c,v 1.3 2013/09/23 14:14:30 dcoppa Exp $

Revert to the old xcb-util-0.3.6 API


commit a0e45e878e450d890a0ab541d48d8dd6c1ede943
Author: Uli Schlachter <psychon@znc.in>
Date:   Thu Aug 1 11:48:03 2013 +0200

client: Ignore "fake" string property changes

I noticed high CPU usage while using asunder. The reason was that asunder
re-sets its window name every 0.1 seconds (and awesome's drawing code is way too
slow).

A semi-fix for this is to ignore string property changes if the old and new
value for the property are equal.

Signed-off-by: Uli Schlachter <psychon@znc.in>


commit 11bef0795a450865b589c1c906bf97141436d314
Author: Uli Schlachter <psychon@znc.in>
Date:   Mon Sep 16 12:06:10 2013 +0200

client.content: Use correct client size (FS#1150)

The size saved in c->geometry also includes the titlebars. Thus, for getting the
window content, we have to subtract this from the size.

Before this, the call to xcb_image_get() was failing with a BadMatch error,
because we were asking for an area that is outside of the actual client's
window's geometry.

Signed-off-by: Uli Schlachter <psychon@znc.in>

--- objects/client.c.orig	Mon Apr  1 13:44:46 2013
+++ objects/client.c	Mon Sep 23 15:57:33 2013
@@ -46,7 +46,7 @@ static void
 client_wipe(client_t *c)
 {
     key_array_wipe(&c->keys);
-    xcb_icccm_get_wm_protocols_reply_wipe(&c->protocols);
+    xcb_get_wm_protocols_reply_wipe(&c->protocols);
     p_delete(&c->machine);
     p_delete(&c->class);
     p_delete(&c->instance);
@@ -71,20 +71,20 @@ client_set_urgent(lua_State *L, int cidx, bool urgent)
     if(c->urgent != urgent)
     {
         xcb_get_property_cookie_t hints =
-            xcb_icccm_get_wm_hints_unchecked(globalconf.connection, c->window);
+            xcb_get_wm_hints_unchecked(globalconf.connection, c->window);
 
         c->urgent = urgent;
 
         /* update ICCCM hints */
-        xcb_icccm_wm_hints_t wmh;
-        xcb_icccm_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
+        xcb_wm_hints_t wmh;
+        xcb_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
 
         if(urgent)
-            wmh.flags |= XCB_ICCCM_WM_HINT_X_URGENCY;
+            wmh.flags |= XCB_WM_HINT_X_URGENCY;
         else
-            wmh.flags &= ~XCB_ICCCM_WM_HINT_X_URGENCY;
+            wmh.flags &= ~XCB_WM_HINT_X_URGENCY;
 
-        xcb_icccm_set_wm_hints(globalconf.connection, c->window, &wmh);
+        xcb_set_wm_hints(globalconf.connection, c->window, &wmh);
 
         luaA_object_emit_signal(L, cidx, "property::urgent", 0);
     }
@@ -113,6 +113,11 @@ DO_CLIENT_SET_PROPERTY(skip_taskbar)
     client_set_##prop(lua_State *L, int cidx, char *value) \
     { \
         client_t *c = luaA_checkudata(L, cidx, &client_class); \
+        if (A_STREQ(c->prop, value)) \
+        { \
+            p_delete(&value); \
+            return; \
+        } \
         p_delete(&c->prop); \
         c->prop = value; \
         luaA_object_emit_signal(L, cidx, "property::" #signal, 0); \
@@ -561,7 +566,7 @@ HANDLE_GEOM(height)
      *
      * At this stage it's just safer to keep it in normal state and avoid confusion.
      */
-    xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_NORMAL);
+    xwindow_set_state(c->window, XCB_WM_STATE_NORMAL);
 
     if(!startup)
     {
@@ -633,26 +638,26 @@ client_apply_size_hints(client_t *c, area_t geometry)
     /* Size hints are applied to the window without any decoration */
     client_remove_titlebar_geometry(c, &geometry);
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
     {
         basew = c->size_hints.base_width;
         baseh = c->size_hints.base_height;
         real_basew = basew;
         real_baseh = baseh;
     }
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         /* base size is substituted with min size if not specified */
         basew = c->size_hints.min_width;
         baseh = c->size_hints.min_height;
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         minw = c->size_hints.min_width;
         minh = c->size_hints.min_height;
     }
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
     {
         /* min size is substituted with base size if not specified */
         minw = c->size_hints.base_width;
@@ -660,7 +665,7 @@ client_apply_size_hints(client_t *c, area_t geometry)
     }
 
     /* Handle the size aspect ratio */
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_ASPECT
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_ASPECT
             && c->size_hints.min_aspect_den > 0
             && c->size_hints.max_aspect_den > 0
             && geometry.height > real_baseh
@@ -701,7 +706,7 @@ client_apply_size_hints(client_t *c, area_t geometry)
     geometry.height = MAX(geometry.height, minh);
 
     /* Handle the maximum size */
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MAX_SIZE)
     {
         if(c->size_hints.max_width)
             geometry.width = MIN(geometry.width, c->size_hints.max_width);
@@ -710,7 +715,7 @@ client_apply_size_hints(client_t *c, area_t geometry)
     }
 
     /* Handle the size increment */
-    if(c->size_hints.flags & (XCB_ICCCM_SIZE_HINT_P_RESIZE_INC | XCB_ICCCM_SIZE_HINT_BASE_SIZE)
+    if(c->size_hints.flags & (XCB_SIZE_HINT_P_RESIZE_INC | XCB_SIZE_HINT_BASE_SIZE)
        && c->size_hints.width_inc && c->size_hints.height_inc)
     {
         uint16_t t1 = geometry.width, t2 = geometry.height;
@@ -892,9 +897,9 @@ client_set_minimized(lua_State *L, int cidx, bool s)
         c->minimized = s;
         banning_need_update();
         if(s)
-            xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_ICONIC);
+            xwindow_set_state(c->window, XCB_WM_STATE_ICONIC);
         else
-            xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_NORMAL);
+            xwindow_set_state(c->window, XCB_WM_STATE_NORMAL);
         if(strut_has_value(&c->strut))
             screen_emit_signal(globalconf.L, c->screen, "property::workarea", 0);
         luaA_object_emit_signal(L, cidx, "property::minimized", 0);
@@ -1197,7 +1202,7 @@ client_unmanage(client_t *c, bool window_valid)
 
         /* Do this last to avoid races with clients. According to ICCCM, clients
          * arent allowed to re-use the window until after this. */
-        xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_WITHDRAWN);
+        xwindow_set_state(c->window, XCB_WM_STATE_WITHDRAWN);
     }
 
     /* set client as invalid */
@@ -1784,11 +1789,16 @@ LUA_OBJECT_EXPORT_PROPERTY(client, client_t, maximized
 static int
 luaA_client_get_content(lua_State *L, client_t *c)
 {
-    xcb_image_t *ximage = xcb_image_get(globalconf.connection,
+    xcb_image_t *ximage;
+    int width  = c->geometry.width;
+    int height = c->geometry.height;
+
+    width  -= c->titlebar[CLIENT_TITLEBAR_LEFT].size + c->titlebar[CLIENT_TITLEBAR_RIGHT].size;
+    height -= c->titlebar[CLIENT_TITLEBAR_TOP].size + c->titlebar[CLIENT_TITLEBAR_BOTTOM].size;
+    ximage = xcb_image_get(globalconf.connection,
                                         c->window,
                                         0, 0,
-                                        c->geometry.width,
-                                        c->geometry.height,
+                                        width, height,
                                         ~0, XCB_IMAGE_FORMAT_Z_PIXMAP);
     cairo_surface_t *surface = NULL;
 
@@ -1861,9 +1871,9 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
 
     lua_createtable(L, 0, 1);
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_US_POSITION)
+    if(c->size_hints.flags & XCB_SIZE_HINT_US_POSITION)
         u_or_p = "user_position";
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_POSITION)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_POSITION)
         u_or_p = "program_position";
 
     if(u_or_p)
@@ -1877,9 +1887,9 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         u_or_p = NULL;
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_US_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_US_SIZE)
         u_or_p = "user_size";
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
         u_or_p = "program_size";
 
     if(u_or_p)
@@ -1892,7 +1902,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, u_or_p);
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         lua_pushnumber(L, c->size_hints.min_width);
         lua_setfield(L, -2, "min_width");
@@ -1900,7 +1910,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "min_height");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MAX_SIZE)
     {
         lua_pushnumber(L, c->size_hints.max_width);
         lua_setfield(L, -2, "max_width");
@@ -1908,7 +1918,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "max_height");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_RESIZE_INC)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_RESIZE_INC)
     {
         lua_pushnumber(L, c->size_hints.width_inc);
         lua_setfield(L, -2, "width_inc");
@@ -1916,7 +1926,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "height_inc");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_ASPECT)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_ASPECT)
     {
         lua_pushnumber(L, c->size_hints.min_aspect_num);
         lua_setfield(L, -2, "min_aspect_num");
@@ -1928,7 +1938,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "max_aspect_den");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_BASE_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_BASE_SIZE)
     {
         lua_pushnumber(L, c->size_hints.base_width);
         lua_setfield(L, -2, "base_width");
@@ -1936,7 +1946,7 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "base_height");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_WIN_GRAVITY)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_WIN_GRAVITY)
     {
         switch(c->size_hints.win_gravity)
         {
