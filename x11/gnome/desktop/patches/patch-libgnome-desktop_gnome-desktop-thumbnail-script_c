REVERT (linux only):
From c4dbe0c297d920e645d509cbc840a3de8b36321d Mon Sep 17 00:00:00 2001
From: Michael Catanzaro <mcatanzaro@redhat.com>
Date: Thu, 6 Nov 2025 15:58:08 -0600
Subject: [PATCH] thumbnail-script: update seccomp filters from flatpak-run.c

Index: libgnome-desktop/gnome-desktop-thumbnail-script.c
--- libgnome-desktop/gnome-desktop-thumbnail-script.c.orig
+++ libgnome-desktop/gnome-desktop-thumbnail-script.c
@@ -27,11 +27,9 @@
 #include "config.h"
 
 #include <gio/gio.h>
-#include <glib/gi18n.h>
 #include <glib/gstdio.h>
 #include <string.h>
 #include <stdlib.h>
-#include <sys/personality.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
@@ -178,9 +176,6 @@ get_extension (const char *path)
 }
 
 #ifdef ENABLE_SECCOMP
-
-#define FLATPAK_ERROR_SETUP_FAILED 0 /* ignored */
-
 static gboolean
 flatpak_fail (GError     **error,
 	      const char  *msg,
@@ -190,16 +185,6 @@ flatpak_fail (GError     **error,
   return FALSE;
 }
 
-static gboolean
-flatpak_fail_error (GError     **error,
-                    int          unused_error,
-	            const char  *msg,
-	            ...)
-{
-  g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, msg);
-  return FALSE;
-}
-
 /* From https://github.com/flatpak/flatpak/blob/master/common/flatpak-utils.c */
 #if !defined(__i386__) && !defined(__x86_64__) && !defined(__aarch64__) && !defined(__arm__)
 static const char *
@@ -293,38 +278,6 @@ static const guint32 seccomp_x86_64_extra_arches[] = {
 static const guint32 seccomp_aarch64_extra_arches[] = { SCMP_ARCH_ARM, 0 };
 #endif
 
-/*
- * @negative_errno: Result code as returned by libseccomp functions
- *
- * Translate a libseccomp error code into an error message. libseccomp
- * mostly returns negative `errno` values such as `-ENOMEM`, but some
- * standard `errno` values are used for non-standard purposes where their
- * `strerror()` would be misleading.
- *
- * Returns: a string version of @negative_errno if possible
- */
-static const char *
-flatpak_seccomp_strerror (int negative_errno)
-{
-  g_return_val_if_fail (negative_errno < 0, "Non-negative error value from libseccomp?");
-  g_return_val_if_fail (negative_errno > INT_MIN, "Out of range error value from libseccomp?");
-
-  switch (negative_errno)
-    {
-      case -EDOM:
-        return "Architecture specific failure";
-
-      case -EFAULT:
-        return "Internal libseccomp failure (unknown syscall?)";
-
-      case -ECANCELED:
-        return "System failure beyond the control of libseccomp";
-    }
-
-  /* e.g. -ENOMEM: the result of strerror() is good enough */
-  return g_strerror (-negative_errno);
-}
-
 static inline void
 cleanup_seccomp (void *p)
 {
@@ -338,7 +291,6 @@ static gboolean
 setup_seccomp (GPtrArray  *argv_array,
                GArray     *fd_array,
                const char *arch,
-               gulong      allowed_personality,
                gboolean    multiarch,
                gboolean    devel,
                GError    **error)
@@ -347,130 +299,122 @@ setup_seccomp (GPtrArray  *argv_array,
 
   /**** BEGIN NOTE ON CODE SHARING
    *
-   * This code is copied from Flatpak:
+   * There are today a number of different Linux container
+   * implementations.  That will likely continue for long into the
+   * future.  But we can still try to share code, and it's important
+   * to do so because it affects what library and application writers
+   * can do, and we should support code portability between different
+   * container tools.
    *
-   *   https://github.com/flatpak/flatpak/blob/main/common/flatpak-run.c
+   * This syscall blocklist is copied from linux-user-chroot, which was in turn
+   * clearly influenced by the Sandstorm.io blocklist.
    *
-   * It should be routinely updated to account for changes in Flatpak.
+   * If you make any changes here, I suggest sending the changes along
+   * to other sandbox maintainers.  Using the libseccomp list is also
+   * an appropriate venue:
+   * https://groups.google.com/forum/#!topic/libseccomp
    *
-   * We ought to split this code out of Flatpak into a subproject, to make
-   * make code sharing easier and reduce the need for manual copy/pasting.
+   * A non-exhaustive list of links to container tooling that might
+   * want to share this blocklist:
    *
+   *  https://github.com/sandstorm-io/sandstorm
+   *    in src/sandstorm/supervisor.c++
+   *  http://cgit.freedesktop.org/xdg-app/xdg-app/
+   *    in common/flatpak-run.c
+   *  https://git.gnome.org/browse/linux-user-chroot
+   *    in src/setup-seccomp.c
+   *
    **** END NOTE ON CODE SHARING
    */
   struct
   {
     int                  scall;
-    int                  errnum;
     struct scmp_arg_cmp *arg;
   } syscall_blocklist[] = {
     /* Block dmesg */
-    {SCMP_SYS (syslog), EPERM},
+    {SCMP_SYS (syslog)},
     /* Useless old syscall */
-    {SCMP_SYS (uselib), EPERM},
+    {SCMP_SYS (uselib)},
+    /* Don't allow you to switch to bsd emulation or whatnot */
+    {SCMP_SYS (personality)},
     /* Don't allow disabling accounting */
-    {SCMP_SYS (acct), EPERM},
+    {SCMP_SYS (acct)},
+    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a
+       historic source of interesting information leaks. */
+    {SCMP_SYS (modify_ldt)},
     /* Don't allow reading current quota use */
-    {SCMP_SYS (quotactl), EPERM},
+    {SCMP_SYS (quotactl)},
 
     /* Don't allow access to the kernel keyring */
-    {SCMP_SYS (add_key), EPERM},
-    {SCMP_SYS (keyctl), EPERM},
-    {SCMP_SYS (request_key), EPERM},
+    {SCMP_SYS (add_key)},
+    {SCMP_SYS (keyctl)},
+    {SCMP_SYS (request_key)},
 
     /* Scary VM/NUMA ops */
-    {SCMP_SYS (move_pages), EPERM},
-    {SCMP_SYS (mbind), EPERM},
-    {SCMP_SYS (get_mempolicy), EPERM},
-    {SCMP_SYS (set_mempolicy), EPERM},
-    {SCMP_SYS (migrate_pages), EPERM},
+    {SCMP_SYS (move_pages)},
+    {SCMP_SYS (mbind)},
+    {SCMP_SYS (get_mempolicy)},
+    {SCMP_SYS (set_mempolicy)},
+    {SCMP_SYS (migrate_pages)},
 
     /* Don't allow subnamespace setups: */
-    {SCMP_SYS (unshare), EPERM},
-    {SCMP_SYS (setns), EPERM},
-    {SCMP_SYS (mount), EPERM},
-    {SCMP_SYS (umount), EPERM},
-    {SCMP_SYS (umount2), EPERM},
-    {SCMP_SYS (pivot_root), EPERM},
-    {SCMP_SYS (chroot), EPERM},
+    {SCMP_SYS (unshare)},
+    {SCMP_SYS (mount)},
+    {SCMP_SYS (pivot_root)},
 #if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)
     /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack
      * and flags arguments are reversed so the flags come second */
-    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
+    {SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
 #else
     /* Normally the flags come first */
-    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
+    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
 #endif
 
     /* Don't allow faking input to the controlling tty (CVE-2017-5226) */
-    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},
-    /* In the unlikely event that the controlling tty is a Linux virtual
-     * console (/dev/tty2 or similar), copy/paste operations have an effect
-     * similar to TIOCSTI (CVE-2023-28100) */
-    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCLINUX)},
-
-    /* seccomp can't look into clone3()'s struct clone_args to check whether
-     * the flags are OK, so we have no choice but to block clone3().
-     * Return ENOSYS so user-space will fall back to clone().
-     * (CVE-2021-41133; see also https://github.com/moby/moby/commit/9f6b562d) */
-    {SCMP_SYS (clone3), ENOSYS},
-
-    /* New mount manipulation APIs can also change our VFS. There's no
-     * legitimate reason to do these in the sandbox, so block all of them
-     * rather than thinking about which ones might be dangerous.
-     * (CVE-2021-41133) */
-    {SCMP_SYS (open_tree), ENOSYS},
-    {SCMP_SYS (move_mount), ENOSYS},
-    {SCMP_SYS (fsopen), ENOSYS},
-    {SCMP_SYS (fsconfig), ENOSYS},
-    {SCMP_SYS (fsmount), ENOSYS},
-    {SCMP_SYS (fspick), ENOSYS},
-    {SCMP_SYS (mount_setattr), ENOSYS},
+    {SCMP_SYS (ioctl), &SCMP_A1(SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int)TIOCSTI)},
   };
 
   struct
   {
     int                  scall;
-    int                  errnum;
     struct scmp_arg_cmp *arg;
   } syscall_nondevel_blocklist[] = {
     /* Profiling operations; we expect these to be done by tools from outside
      * the sandbox.  In particular perf has been the source of many CVEs.
      */
-    {SCMP_SYS (perf_event_open), EPERM},
-    /* Don't allow you to switch to bsd emulation or whatnot */
-    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},
-    {SCMP_SYS (ptrace), EPERM}
+    {SCMP_SYS (perf_event_open)},
+    {SCMP_SYS (ptrace)}
   };
-  /* Blocklist all but unix, inet, inet6 and netlink */
-  struct
-  {
-    int             family;
-    int /* FlatpakRunFlags */ unused_flags_mask;
-  } socket_family_allowlist[] = {
-    /* NOTE: Keep in numerical order */
-    { AF_UNSPEC, 0 },
-    { AF_LOCAL, 0 },
-    { AF_INET, 0 },
-    { AF_INET6, 0 },
-    { AF_NETLINK, 0 },
-    /* { AF_CAN, FLATPAK_RUN_FLAG_CANBUS }, */
-    /* { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH }, */
+  /* blocklist all but unix, inet, inet6 and netlink */
+  int socket_family_blocklist[] = {
+    AF_AX25,
+    AF_IPX,
+    AF_APPLETALK,
+    AF_NETROM,
+    AF_BRIDGE,
+    AF_ATMPVC,
+    AF_X25,
+    AF_ROSE,
+    AF_DECnet,
+    AF_NETBEUI,
+    AF_SECURITY,
+    AF_KEY,
+    AF_NETLINK + 1, /* Last gets CMP_GE, so order is important */
   };
-  int last_allowed_family;
-  int i, r;
+  guint i;
+  int r;
   int fd = -1;
   g_autofree char *fd_str = NULL;
   g_autofree char *path = NULL;
 
   seccomp = seccomp_init (SCMP_ACT_ALLOW);
   if (!seccomp)
-    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Initialize seccomp failed"));
+    return flatpak_fail (error, "Initialize seccomp failed");
 
   if (arch != NULL)
     {
-      uint32_t arch_id = 0;
-      const uint32_t *extra_arches = NULL;
+      guint32 arch_id = 0;
+      const guint32 *extra_arches = NULL;
 
       if (strcmp (arch, "i386") == 0)
         {
@@ -504,7 +448,7 @@ setup_seccomp (GPtrArray  *argv_array,
              couldn't continue running. */
           r = seccomp_arch_add (seccomp, arch_id);
           if (r < 0 && r != -EEXIST)
-            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Failed to add architecture to seccomp filter: %s"), flatpak_seccomp_strerror (r));
+            return flatpak_fail (error, "Failed to add architecture to seccomp filter");
 
           if (multiarch && extra_arches != NULL)
             {
@@ -512,7 +456,7 @@ setup_seccomp (GPtrArray  *argv_array,
                 {
                   r = seccomp_arch_add (seccomp, extra_arches[i]);
                   if (r < 0 && r != -EEXIST)
-                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Failed to add multiarch architecture to seccomp filter: %s"), flatpak_seccomp_strerror (r));
+                    return flatpak_fail (error, "Failed to add multiarch architecture to seccomp filter");
                 }
             }
         }
@@ -526,94 +470,41 @@ setup_seccomp (GPtrArray  *argv_array,
   for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)
     {
       int scall = syscall_blocklist[i].scall;
-      int errnum = syscall_blocklist[i].errnum;
-
-      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);
-
       if (syscall_blocklist[i].arg)
-        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);
+        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);
       else
-        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);
-
-      /* EFAULT means "internal libseccomp error", but in practice we get
-       * this for syscall numbers added via flatpak-syscalls-private.h
-       * when trying to filter them on a non-native architecture, because
-       * libseccomp cannot map the syscall number to a name and back to a
-       * number for the non-native architecture. */
-      if (r == -EFAULT)
-        g_debug ("Unable to block syscall %d: syscall not known to libseccomp?",
-                 scall);
-      else if (r < 0)
-        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Failed to block syscall %d: %s"), scall, flatpak_seccomp_strerror (r));
+        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);
+      if (r < 0 && r == -EFAULT /* unknown syscall */)
+        return flatpak_fail (error, "Failed to block syscall %d", scall);
     }
 
-  if (!multiarch)
-    {
-      /* modify_ldt is a historic source of interesting information leaks,
-       * so it's disabled as a hardening measure.
-       * However, it is required to run old 16-bit applications
-       * as well as some Wine patches, so it's allowed in multiarch. */
-      int scall = SCMP_SYS (modify_ldt);
-      r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);
-
-      /* See above for the meaning of EFAULT. */
-      if (r == -EFAULT)
-        g_debug ("Unable to block syscall %d: syscall not known to libseccomp?",
-                 scall);
-      else if (r < 0)
-        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Failed to block syscall %d: %s"), scall, flatpak_seccomp_strerror (r));
-    }
-
   if (!devel)
     {
       for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)
         {
           int scall = syscall_nondevel_blocklist[i].scall;
-          int errnum = syscall_nondevel_blocklist[i].errnum;
-
-          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);
-
           if (syscall_nondevel_blocklist[i].arg)
-            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);
+            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);
           else
-            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);
+            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);
 
-          /* See above for the meaning of EFAULT. */
-          if (r == -EFAULT)
-            g_debug ("Unable to block syscall %d: syscall not known to libseccomp?",
-                     scall);
-          else if (r < 0)
-            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _("Failed to block syscall %d: %s"), scall, flatpak_seccomp_strerror (r));
+          if (r < 0 && r == -EFAULT /* unknown syscall */)
+            return flatpak_fail (error, "Failed to block syscall %d", scall);
         }
     }
 
   /* Socket filtering doesn't work on e.g. i386, so ignore failures here
    * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing
    * something else: https://github.com/seccomp/libseccomp/issues/8 */
-  last_allowed_family = -1;
-  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)
+  for (i = 0; i < G_N_ELEMENTS (socket_family_blocklist); i++)
     {
-      int family = socket_family_allowlist[i].family;
-      int disallowed;
-
-/*
-      if (socket_family_allowlist[i].flags_mask != 0 &&
-          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)
-        continue;
- */
-
-      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)
-        {
-          /* Blocklist the in-between valid families */
-          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));
-        }
-      last_allowed_family = family;
+      int family = socket_family_blocklist[i];
+      if (i == G_N_ELEMENTS (socket_family_blocklist) - 1)
+        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, family));
+      else
+        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, family));
     }
-  /* Blocklist the rest */
-  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));
 
-  /* Code below this point is based on an earlier version of flatpak-run.c. */
-
   fd = g_file_open_tmp ("flatpak-seccomp-XXXXXX", &path, error);
   if (fd == -1)
     return FALSE;
@@ -887,7 +778,6 @@ expand_thumbnailing_cmd (const char  *cmd,
       if (!setup_seccomp (array,
                           script->fd_array,
                           arch,
-                          PER_LINUX,
                           FALSE,
                           FALSE,
                           error))
