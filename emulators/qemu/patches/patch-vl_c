$OpenBSD: patch-vl_c,v 1.14 2007/05/01 12:55:14 todd Exp $
--- vl.c.orig	Mon Feb  5 17:01:54 2007
+++ vl.c	Sat Apr 21 19:48:30 2007
@@ -44,7 +44,8 @@
 #include <netdb.h>
 #ifdef _BSD
 #include <sys/stat.h>
-#ifndef __APPLE__
+#include <net/if.h>
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
 #include <libutil.h>
 #endif
 #else
@@ -168,6 +169,7 @@ const char *vnc_display;
 int acpi_enabled = 1;
 int fd_bootchk = 1;
 int no_reboot = 0;
+int scsi_enabled = 0;
 int daemonize = 0;
 const char *option_rom[MAX_OPTION_ROMS];
 int nb_option_roms;
@@ -2808,7 +2810,7 @@ static int parse_macaddr(uint8_t *macaddr, const char 
     return 0;
 }
 
-static int get_str_sep(char *buf, int buf_size, const char **pp, int sep)
+static int get_str_sep(char *buf, size_t buf_size, const char **pp, int sep)
 {
     const char *p, *p1;
     int len;
@@ -3226,11 +3228,85 @@ static int tap_open(char *ifname, int ifname_size)
     char *dev;
     struct stat s;
 
+    /* If the device was specified on the command line, use it */
+    if (ifname[0]) {
+       fd = open(ifname, O_RDWR);
+       if (fd < 0) {
+          fprintf(stderr, "warning: could not open %s: no virtual network emulation\n", ifname);
+            return -1;
+       }
+    } else {
+#ifdef __OpenBSD__
+    struct ifreq ifr;
+    int i = 0, enoentcount = 0, err = 0, sock;
+    char dname[100], iname[100];
+
+    bzero(&ifr, sizeof(ifr));
+    if (ifname != NULL && ifname[0] != '\0') {
+        snprintf(dname, sizeof(dname), "/dev/%s", ifname);
+        strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+        fd = open(dname, O_RDWR);
+    } else {
+        for (; i != -1; i++) {
+           snprintf(dname, sizeof dname, "/dev/tun%d", i);
+            bzero(&ifr.ifr_name, sizeof(ifr.ifr_name));
+           snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", i);
+           fd = open(dname, O_RDWR);
+           if (fd >= 0)
+               break;
+           else if (errno != ENOENT || ++enoentcount > 3) {
+                if (errno != EBUSY) {
+                    err = errno;
+                    break;
+                }
+            } else
+                err = errno;
+        }
+    }
+    if (fd < 0) {
+       fprintf(stderr, "warning: could not open %s (%s): no virtual "
+           "network emulation\n", dname, strerror(err));
+       return -1;
+    }
+
+    /* Set the tunnel device operation mode */
+    if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {
+        close(fd);
+        return -1;
+    }
+
+    /* Get interface flags */
+    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Set interface mode */
+    ifr.ifr_flags &= ~IFF_UP;
+    ifr.ifr_flags |= IFF_LINK0;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Bring interface up */
+    ifr.ifr_flags |= IFF_UP;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+#else
     fd = open("/dev/tap", O_RDWR);
     if (fd < 0) {
         fprintf(stderr, "warning: could not open /dev/tap: no virtual network emulation\n");
         return -1;
     }
+#endif
+    }
 
     fstat(fd, &s);
     dev = devname(s.st_rdev, S_IFCHR);
@@ -3282,6 +3358,7 @@ static int net_tap_init(VLANState *vlan, const char *i
     char *args[3];
     char **parg;
     char ifname[128];
+    bzero(&ifname,sizeof(ifname));
 
     if (ifname1 != NULL)
         pstrcpy(ifname, sizeof(ifname), ifname1);
@@ -3476,7 +3553,7 @@ static int net_socket_mcast_create(struct sockaddr_in 
     /* Force mcast msgs to loopback (eg. several QEMUs in same host */
     val = 1;
     ret=setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, 
-                   (const char *)&val, sizeof(val));
+                   (const char *)&val, sizeof(char));
     if (ret < 0) {
 	perror("setsockopt(SOL_IP, IP_MULTICAST_LOOP)");
 	goto fail;
@@ -3732,7 +3809,8 @@ static int net_socket_mcast_init(VLANState *vlan, cons
 
 }
 
-static int get_param_value(char *buf, int buf_size,
+static int get_param_value(char *, size_t, const char *, const char *);
+static int get_param_value(char *buf, size_t buf_size,
                            const char *tag, const char *str)
 {
     const char *p;
@@ -3856,6 +3934,8 @@ static int net_client_init(const char *str)
     if (!strcmp(device, "tap")) {
         char ifname[64];
         char setup_script[1024];
+	bzero(&ifname,sizeof(ifname));
+	bzero(&setup_script,sizeof(setup_script));
         int fd;
         if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {
             fd = strtol(buf, NULL, 0);
@@ -3863,13 +3943,13 @@ static int net_client_init(const char *str)
             if (net_tap_fd_init(vlan, fd))
                 ret = 0;
         } else {
-            if (get_param_value(ifname, sizeof(ifname), "ifname", p) <= 0) {
-                ifname[0] = '\0';
-            }
             if (get_param_value(setup_script, sizeof(setup_script), "script", p) == 0) {
                 pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);
             }
-            ret = net_tap_init(vlan, ifname, setup_script);
+            if (get_param_value(ifname, sizeof(ifname), "ifname", p) == 0)
+		ret = net_tap_init(vlan, NULL, setup_script);
+	    else
+		ret = net_tap_init(vlan, NULL, setup_script);
         }
     } else
 #endif
@@ -6117,6 +6197,7 @@ void help(void)
            "-no-acpi        disable ACPI\n"
 #endif
            "-no-reboot      exit instead of rebooting\n"
+           "-scsienable     enable scsi devices\n"
            "-loadvm file    start right away with a saved state (loadvm in monitor)\n"
 	   "-vnc display    start a VNC server on display\n"
 #ifndef _WIN32
@@ -6205,7 +6286,8 @@ enum {
     QEMU_OPTION_no_reboot,
     QEMU_OPTION_daemonize,
     QEMU_OPTION_option_rom,
-    QEMU_OPTION_semihosting
+    QEMU_OPTION_semihosting,
+    QEMU_OPTION_scsi
 };
 
 typedef struct QEMUOption {
@@ -6281,6 +6363,7 @@ const QEMUOption qemu_options[] = {
     { "usbdevice", HAS_ARG, QEMU_OPTION_usbdevice },
     { "smp", HAS_ARG, QEMU_OPTION_smp },
     { "vnc", HAS_ARG, QEMU_OPTION_vnc },
+    { "scsienable", 0, QEMU_OPTION_scsi },
 
     /* temporary options */
     { "usb", 0, QEMU_OPTION_usb },
@@ -6570,7 +6653,11 @@ int main(int argc, char **argv)
     gdbstub_port = DEFAULT_GDBSTUB_PORT;
 #endif
     snapshot = 0;
+#if defined(CONFIG_SDL) || defined(CONFIG_COCOA)
     nographic = 0;
+#else
+    nographic = 1;
+#endif
     kernel_filename = NULL;
     kernel_cmdline = "";
 #ifdef TARGET_PPC
@@ -6580,14 +6667,14 @@ int main(int argc, char **argv)
 #endif
     cyls = heads = secs = 0;
     translation = BIOS_ATA_TRANSLATION_AUTO;
-    pstrcpy(monitor_device, sizeof(monitor_device), "vc");
+    pstrcpy(monitor_device, sizeof(monitor_device), nographic ? "stdio" : "vc" );
 
-    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), "vc");
+    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), nographic ? "stdio" : "vc");
     for(i = 1; i < MAX_SERIAL_PORTS; i++)
         serial_devices[i][0] = '\0';
     serial_device_index = 0;
     
-    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "vc");
+    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "null");
     for(i = 1; i < MAX_PARALLEL_PORTS; i++)
         parallel_devices[i][0] = '\0';
     parallel_device_index = 0;
@@ -6940,6 +7027,9 @@ int main(int argc, char **argv)
 		break;
             case QEMU_OPTION_no_acpi:
                 acpi_enabled = 0;
+                break;
+            case QEMU_OPTION_scsi:
+                scsi_enabled = 1;
                 break;
             case QEMU_OPTION_no_reboot:
                 no_reboot = 1;
