--- vl.c.orig	Mon Dec 19 16:51:53 2005
+++ vl.c	Mon Apr 10 16:02:04 2006
@@ -43,7 +43,8 @@
 #include <netdb.h>
 #ifdef _BSD
 #include <sys/stat.h>
-#ifndef __APPLE__
+#include <net/if.h>
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
 #include <libutil.h>
 #endif
 #else
@@ -126,6 +127,7 @@ QEMUTimer *gui_timer;
 int vm_running;
 int rtc_utc = 1;
 int cirrus_vga_enabled = 1;
+int nic_pcnet = 0;
 #ifdef TARGET_SPARC
 int graphic_width = 1024;
 int graphic_height = 768;
@@ -288,7 +290,7 @@ void isa_unassign_ioport(int start, int 
 
 /***********************************************************/
 
-void pstrcpy(char *buf, int buf_size, const char *str)
+void pstrcpy(char *buf, size_t buf_size, const char *str)
 {
     int c;
     char *q = buf;
@@ -306,7 +308,7 @@ void pstrcpy(char *buf, int buf_size, co
 }
 
 /* strcat and truncate. */
-char *pstrcat(char *buf, int buf_size, const char *s)
+char *pstrcat(char *buf, size_t buf_size, const char *s)
 {
     int len;
     len = strlen(buf);
@@ -549,7 +551,23 @@ int64_t cpu_get_real_ticks(void)
 }
 
 #else
-#error unsupported CPU
+# warning non-optimized CPU
+#include <sys/time.h>
+#include <time.h>
+
+int64_t cpu_get_real_ticks(void)
+{
+    struct timeval tv;
+    static int64_t i = 0;
+    int64_t j;
+
+    gettimeofday(&tv, NULL);
+    do {
+	j = (tv.tv_sec * (uint64_t) 1000000) + tv.tv_usec;
+    } while (i == j);
+    i = j;
+    return j;
+}
 #endif
 
 static int64_t cpu_ticks_offset;
@@ -1693,7 +1711,7 @@ static int parse_macaddr(uint8_t *macadd
     return 0;
 }
 
-static int get_str_sep(char *buf, int buf_size, const char **pp, int sep)
+static int get_str_sep(char *buf, size_t buf_size, const char **pp, int sep)
 {
     const char *p, *p1;
     int len;
@@ -1768,13 +1786,16 @@ VLANState *qemu_find_vlan(int id)
 }
 
 VLANClientState *qemu_new_vlan_client(VLANState *vlan,
-                                      IOReadHandler *fd_read, void *opaque)
+                                      IOReadHandler *fd_read,
+                                      IOCanRWHandler *fd_can_read,
+                                      void *opaque)
 {
     VLANClientState *vc, **pvc;
     vc = qemu_mallocz(sizeof(VLANClientState));
     if (!vc)
         return NULL;
     vc->fd_read = fd_read;
+    vc->fd_can_read = fd_can_read;
     vc->opaque = opaque;
     vc->vlan = vlan;
 
@@ -1786,6 +1807,20 @@ VLANClientState *qemu_new_vlan_client(VL
     return vc;
 }
 
+int qemu_can_send_packet(VLANClientState *vc1)
+{
+    VLANState *vlan = vc1->vlan;
+    VLANClientState *vc;
+
+    for(vc = vlan->first_client; vc != NULL; vc = vc->next) {
+        if (vc != vc1) {
+            if (vc->fd_can_read && !vc->fd_can_read(vc->opaque))
+                return 0;
+        }
+    }
+    return 1;
+}
+
 void qemu_send_packet(VLANClientState *vc1, const uint8_t *buf, int size)
 {
     VLANState *vlan = vc1->vlan;
@@ -1811,7 +1846,7 @@ static VLANClientState *slirp_vc;
 
 int slirp_can_output(void)
 {
-    return 1;
+    qemu_can_send_packet(slirp_vc);
 }
 
 void slirp_output(const uint8_t *pkt, int pkt_len)
@@ -1839,7 +1874,7 @@ static int net_slirp_init(VLANState *vla
         slirp_init();
     }
     slirp_vc = qemu_new_vlan_client(vlan, 
-                                    slirp_receive, NULL);
+                                    slirp_receive, NULL, NULL);
     snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), "user redirector");
     return 0;
 }
@@ -2024,7 +2059,7 @@ static TAPState *net_tap_fd_init(VLANSta
     if (!s)
         return NULL;
     s->fd = fd;
-    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);
+    s->vc = qemu_new_vlan_client(vlan, tap_receive, NULL, s);
     qemu_set_fd_handler(s->fd, tap_send, NULL, s);
     snprintf(s->vc->info_str, sizeof(s->vc->info_str), "tap: fd=%d", fd);
     return s;
@@ -2037,11 +2072,85 @@ static int tap_open(char *ifname, int if
     char *dev;
     struct stat s;
 
+    /* If the device was specified on the command line, use it */
+    if (ifname[0]) {
+	fd = open(ifname, O_RDWR);
+	if (fd < 0) {
+	   fprintf(stderr, "warning: could not open %s: no virtual network emulation\n", ifname);
+	     return -1;
+	}
+    } else {
+#ifdef __OpenBSD__
+    struct ifreq ifr;
+    int i = 0, enoentcount = 0, err = 0, sock;
+    char dname[100], iname[100];
+
+    bzero(&ifr, sizeof(ifr));
+    if (ifname != NULL && ifname[0] != '\0') {
+        snprintf(dname, sizeof(dname), "/dev/%s", ifname);
+        strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+        fd = open(dname, O_RDWR);
+    } else {
+        for (; i != -1; i++) {
+    	    snprintf(dname, sizeof dname, "/dev/tun%d", i);
+            bzero(&ifr.ifr_name, sizeof(ifr.ifr_name));
+	    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", i);
+	    fd = open(dname, O_RDWR);
+	    if (fd >= 0)
+	        break;
+	    else if (errno != ENOENT || ++enoentcount > 3) {
+                if (errno != EBUSY) {
+                    err = errno;
+                    break;
+                }
+            } else
+                err = errno;
+        }
+    }
+    if (fd < 0) {
+	fprintf(stderr, "warning: could not open %s (%s): no virtual "
+	    "network emulation\n", dname, strerror(err));
+	return -1;
+    }
+
+    /* Set the tunnel device operation mode */
+    if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {
+        close(fd);
+        return -1;
+    }
+
+    /* Get interface flags */
+    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Set interface mode */
+    ifr.ifr_flags &= ~IFF_UP;
+    ifr.ifr_flags |= IFF_LINK0;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Bring interface up */
+    ifr.ifr_flags |= IFF_UP;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+#else
     fd = open("/dev/tap", O_RDWR);
     if (fd < 0) {
         fprintf(stderr, "warning: could not open /dev/tap: no virtual network emulation\n");
         return -1;
     }
+#endif
+    }
 
     fstat(fd, &s);
     dev = devname(s.st_rdev, S_IFCHR);
@@ -2327,7 +2436,7 @@ static NetSocketState *net_socket_fd_ini
         return NULL;
     s->fd = fd;
 
-    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);
+    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, NULL, s);
     qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);
 
     /* mcast: save bound address as dst */
@@ -2355,7 +2464,7 @@ static NetSocketState *net_socket_fd_ini
         return NULL;
     s->fd = fd;
     s->vc = qemu_new_vlan_client(vlan, 
-                                 net_socket_receive, s);
+                                 net_socket_receive, NULL, s);
     snprintf(s->vc->info_str, sizeof(s->vc->info_str),
              "socket: fd=%d", fd);
     if (is_connected) {
@@ -2526,7 +2635,8 @@ static int net_socket_mcast_init(VLANSta
 
 #endif /* !_WIN32 */
 
-static int get_param_value(char *buf, int buf_size,
+static int get_param_value(char *, size_t, const char *, const char *);
+static int get_param_value(char *buf, size_t buf_size,
                            const char *tag, const char *str)
 {
     const char *p;
@@ -2636,17 +2746,21 @@ int net_client_init(const char *str)
         char ifname[64];
         char setup_script[1024];
         int fd;
+	bzero(&ifname,sizeof(ifname));
+	bzero(&setup_script,sizeof(setup_script));
         if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {
             fd = strtol(buf, NULL, 0);
             ret = -1;
             if (net_tap_fd_init(vlan, fd))
                 ret = 0;
         } else {
-            get_param_value(ifname, sizeof(ifname), "ifname", p);
             if (get_param_value(setup_script, sizeof(setup_script), "script", p) == 0) {
                 pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);
             }
-            ret = net_tap_init(vlan, ifname, setup_script);
+            if (get_param_value(ifname, sizeof(ifname), "ifname", p) == 0)
+		ret = net_tap_init(vlan, NULL, setup_script);
+	    else
+            	ret = net_tap_init(vlan, ifname, setup_script);
         }
     } else
     if (!strcmp(device, "socket")) {
@@ -3986,6 +4100,7 @@ void help(void)
 #if defined(TARGET_PPC) || defined(TARGET_SPARC)
            "-g WxH[xDEPTH]  Set the initial graphical resolution and depth\n"
 #endif
+           "-nic-pcnet     simulate an AMD PC-Net PCI ethernet adaptor\n"
            "\n"
            "Network options:\n"
            "-net nic[,vlan=n][,macaddr=addr]\n"
@@ -4093,6 +4208,7 @@ enum {
     QEMU_OPTION_audio_help,
     QEMU_OPTION_soundhw,
 #endif
+    QEMU_OPTION_nic_pcnet,
 
     QEMU_OPTION_net,
     QEMU_OPTION_tftp,
@@ -4195,6 +4311,7 @@ const QEMUOption qemu_options[] = {
     
     /* temporary options */
     { "usb", 0, QEMU_OPTION_usb },
+    { "nic-pcnet", 0, QEMU_OPTION_nic_pcnet },
     { "cirrusvga", 0, QEMU_OPTION_cirrusvga },
     { NULL },
 };
@@ -4441,7 +4558,7 @@ int main(int argc, char **argv)
         serial_devices[i][0] = '\0';
     serial_device_index = 0;
     
-    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "vc");
+    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "null");
     for(i = 1; i < MAX_PARALLEL_PORTS; i++)
         parallel_devices[i][0] = '\0';
     parallel_device_index = 0;
@@ -4601,6 +4718,9 @@ int main(int argc, char **argv)
                         optarg);
                 nb_net_clients++;
                 break;
+            case QEMU_OPTION_nic_pcnet:
+		nic_pcnet = 1;
+		break;
 #ifdef CONFIG_SLIRP
             case QEMU_OPTION_tftp:
 		tftp_prefix = optarg;
