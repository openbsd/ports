$OpenBSD: patch-iodev_dma_cc,v 1.1 2001/02/02 16:59:11 todd Exp $
--- iodev/dma.cc.orig	Sat Mar 25 21:28:48 2000
+++ iodev/dma.cc	Tue Oct 31 12:16:53 2000
@@ -140,12 +140,12 @@ bx_dma_c::read( Bit32u   address, unsign
   Bit8u channel;
 
   if (io_len > 1) {
-    bx_panic("dma: io read from address %08x, len=%u\n",
+    bio->panic("[DMA] io read from address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
     }
 
-  if (bx_dbg.dma)
-    bx_printf("dma: read addr=%04x\n", (unsigned) address);
+  if (bio->getdbg().dma)
+    bio->printf("[DMA] read addr=%04x\n", (unsigned) address);
 
 #if BX_DMA_FLOPPY_IO < 1
   /* if we're not supporting DMA/floppy IO just return a bogus value */
@@ -196,7 +196,7 @@ bx_dma_c::read( Bit32u   address, unsign
       return(retval);
       break;
     case 0x0d: // dma-1: temporary register
-      bx_panic("dma-1: read of temporary register\n");
+      bio->panic("[DMA1] read of temporary register\n");
       // Note: write to 0x0D clears temporary register
       return(0);
       break;
@@ -216,7 +216,8 @@ bx_dma_c::read( Bit32u   address, unsign
     case 0x008b: // DMA-2 page register, channel 5
     case 0x008f: // DMA-2 page register, channel 4
       channel = channelindex[address - 0x89] + 4;
-      bx_printf("dma: read: unsupported address=%04x (channel %d)\n", 
+	if(bio->getdbg().dma)
+      bio->printf("[DMA] read: unsupported address=%04x (channel %d)\n", 
 		(unsigned) address, channel);
       return( 0x00 );
 
@@ -236,12 +237,14 @@ bx_dma_c::read( Bit32u   address, unsign
     case 0x00da:
     case 0x00dc:
     case 0x00de:
-      bx_printf("dma: read: unsupported address=%04x\n", (unsigned) address);
+	if(bio->getdbg().dma)
+      bio->printf("[DMA] read: unsupported address=%04x\n", (unsigned) address);
       return(0x0000);
       break;
 
     default:
-      bx_panic("dma: read: unsupported address=%04x\n", (unsigned) address);
+	if(bio->getdbg().dma)
+      bio->panic("[DMA] read: unsupported address=%04x\n", (unsigned) address);
       return(0);
     }
 }
@@ -282,12 +285,12 @@ bx_dma_c::write(Bit32u   address, Bit32u
       return;
       }
 
-    bx_panic("dma: io write to address %08x, len=%u\n",
+    bio->panic("[DMA] io write to address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
     }
 
-  if (bx_dbg.dma)
-    bx_printf("\ndma: write: address=%04x value=%02x\n",
+  if (bio->getdbg().dma)
+    bio->printf("[DMA] write: address=%04x value=%02x\n",
       (unsigned) address, (unsigned) value);
 
 #if BX_DMA_FLOPPY_IO < 1
@@ -301,8 +304,8 @@ bx_dma_c::write(Bit32u   address, Bit32u
     case 0x04:
     case 0x06:
       channel = address >> 1;
-      if (bx_dbg.dma)
-        bx_printf("  DMA-1 base and current address, channel %d\n", channel);
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1] base and current address, channel %d\n", channel);
       if (BX_DMA_THIS s.flip_flop==0) { /* 1st byte */
         BX_DMA_THIS s.chan[channel].base_address = value;
         BX_DMA_THIS s.chan[channel].current_address = value;
@@ -310,10 +313,10 @@ bx_dma_c::write(Bit32u   address, Bit32u
       else { /* 2nd byte */
         BX_DMA_THIS s.chan[channel].base_address |= (value << 8);
         BX_DMA_THIS s.chan[channel].current_address |= (value << 8);
-        if (bx_dbg.dma) {
-          bx_printf("    base = %04x\n",
+        if (bio->getdbg().dma) {
+          bio->printf("[DMA]    base = %04x\n",
             (unsigned) BX_DMA_THIS s.chan[channel].base_address);
-          bx_printf("    curr = %04x\n",
+          bio->printf("[DMA]    curr = %04x\n",
             (unsigned) BX_DMA_THIS s.chan[channel].current_address);
           }
         }
@@ -326,8 +329,8 @@ bx_dma_c::write(Bit32u   address, Bit32u
     case 0x05:
     case 0x07:
       channel = address >> 1;
-      if (bx_dbg.dma)
-        bx_printf("  DMA-1 base and current count, channel %d\n", channel);
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1]  base and current count, channel %d\n", channel);
       if (BX_DMA_THIS s.flip_flop==0) { /* 1st byte */
         BX_DMA_THIS s.chan[channel].base_count = value;
         BX_DMA_THIS s.chan[channel].current_count = value;
@@ -335,10 +338,10 @@ bx_dma_c::write(Bit32u   address, Bit32u
       else { /* 2nd byte */
         BX_DMA_THIS s.chan[channel].base_count |= (value << 8);
         BX_DMA_THIS s.chan[channel].current_count |= (value << 8);
-        if (bx_dbg.dma) {
-          bx_printf("    base = %04x\n",
+        if (bio->getdbg().dma) {
+          bio->printf("[DMA]    base = %04x\n",
             (unsigned) BX_DMA_THIS s.chan[channel].base_count);
-          bx_printf("    curr = %04x\n",
+          bio->printf("[DMA]    curr = %04x\n",
             (unsigned) BX_DMA_THIS s.chan[channel].current_count);
           }
         }
@@ -348,14 +351,14 @@ bx_dma_c::write(Bit32u   address, Bit32u
 
     case 0x08: /* DMA-1: command register */
       if (value != 0x04)
-        bx_printf("DMA: write to 0008: value(%02xh) not 04h\n",
+        bio->printf("[DMA1] write to 0008: value(%02xh) not 04h\n",
           (unsigned) value);
       BX_DMA_THIS s.command_reg = value;
       return;
       break;
 
     case 0x09: // DMA-1: request register
-      bx_printf("DMA-1: write to request register (%02x)\n", (unsigned) value);
+      bio->printf("[DMA1] write to request register (%02x)\n", (unsigned) value);
       // note: write to 0x0d clears this register
       if (value & 0x04) {
         // set request bit
@@ -366,7 +369,7 @@ bx_dma_c::write(Bit32u   address, Bit32u
         // clear request bit
         channel = value & 0x03;
         BX_DMA_THIS s.status_reg &= ~(1 << (channel+4));
-        bx_printf("dma-1: cleared request bit for channel %u\n", (unsigned) channel);
+        bio->printf("[DMA1] cleared request bit for channel %u\n", (unsigned) channel);
         }
       return;
       break;
@@ -375,8 +378,8 @@ bx_dma_c::write(Bit32u   address, Bit32u
       set_mask_bit = value & 0x04;
       channel = value & 0x03;
       BX_DMA_THIS s.mask[channel] = (set_mask_bit > 0);
-      if (bx_dbg.dma)
-        bx_printf("DMA1: set_mask_bit=%u, channel=%u, mask now=%02xh\n",
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1] set_mask_bit=%u, channel=%u, mask now=%02xh\n",
           (unsigned) set_mask_bit, (unsigned) channel, (unsigned) BX_DMA_THIS s.mask[channel]);
       return;
       break;
@@ -387,24 +390,24 @@ bx_dma_c::write(Bit32u   address, Bit32u
       BX_DMA_THIS s.chan[channel].mode.address_decrement = (value >> 5) & 0x01;
       BX_DMA_THIS s.chan[channel].mode.autoinit_enable = (value >> 4) & 0x01;
       BX_DMA_THIS s.chan[channel].mode.transfer_type = (value >> 2) & 0x03;
-//bx_printf("DMA1: mode register[%u] = %02x\n",
+//bio->printf("[DMA1] mode register[%u] = %02x\n",
 //(unsigned) channel, (unsigned) value);
-      if (bx_dbg.dma)
-        bx_printf("DMA1: mode register[%u] = %02x\n",
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1] mode register[%u] = %02x\n",
           (unsigned) channel, (unsigned) value);
       return;
       break;
 
     case 0x0c: /* dma-1 clear byte flip/flop */
-      if (bx_dbg.dma)
-        bx_printf("DMA1: clear flip/flop\n");
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1] clear flip/flop\n");
       BX_DMA_THIS s.flip_flop = 0;
       return;
       break;
 
     case 0x0d: // dma-1: master disable
       /* ??? */
-      bx_printf("dma: master disable\n");
+      bio->printf("[DMA] master disable\n");
       // writing any value to this port resets DMA controller 1
       // same action as a hardware reset
       // mask register is set (chan 0..3 disabled)
@@ -422,7 +425,7 @@ bx_dma_c::write(Bit32u   address, Bit32u
       break;
 
     case 0x0e: // dma-1: clear mask register
-      bx_printf("dma-1: clear mask register\n");
+      bio->printf("[DMA1] clear mask register\n");
       BX_DMA_THIS s.mask[0] = 0;
       BX_DMA_THIS s.mask[1] = 0;
       BX_DMA_THIS s.mask[2] = 0;
@@ -431,7 +434,7 @@ bx_dma_c::write(Bit32u   address, Bit32u
       break;
 
     case 0x0f: // dma-1: write all mask bits
-      bx_printf("dma-1: write all mask bits\n");
+      bio->printf("[DMA1] write all mask bits\n");
       BX_DMA_THIS s.mask[0] = value & 0x01; value >>= 1;
       BX_DMA_THIS s.mask[1] = value & 0x01; value >>= 1;
       BX_DMA_THIS s.mask[2] = value & 0x01; value >>= 1;
@@ -446,8 +449,8 @@ bx_dma_c::write(Bit32u   address, Bit32u
       /* address bits A16-A23 for DMA channel */
       channel = channelindex[address - 0x81];
       BX_DMA_THIS s.chan[channel].page_reg = value;
-      if (bx_dbg.dma)
-        bx_printf("DMA1: page register %d = %02x\n", channel, (unsigned) value);
+      if (bio->getdbg().dma)
+        bio->printf("[DMA1] page register %d = %02x\n", channel, (unsigned) value);
       return;
       break;
 
@@ -457,7 +460,7 @@ bx_dma_c::write(Bit32u   address, Bit32u
 
     //case 0xd0: /* DMA-2 command register */
     //  if (value != 0x04)
-    //    bx_printf("DMA2: write command register: value(%02xh)!=04h\n",
+    //    bio->printf("[DMA2] write command register: value(%02xh)!=04h\n",
     //      (unsigned) value);
     //  return;
     //  break;
@@ -478,14 +481,14 @@ bx_dma_c::write(Bit32u   address, Bit32u
     case 0x00da:
     case 0x00dc:
     case 0x00de:
-      bx_printf("DMA(ignored): write: %04xh = %04xh\n",
+      bio->printf("[DMA] write: %04xh = %04xh (ignored)\n",
         (unsigned) address, (unsigned) value);
       return;
       break;
 
 
     default:
-      bx_printf("DMA(ignored): write: %04xh = %02xh\n",
+      bio->printf("[DMA] write: %04xh = %02xh (ignored)\n",
         (unsigned) address, (unsigned) value);
     }
 }
@@ -497,15 +500,15 @@ bx_dma_c::DRQ(unsigned channel, Boolean 
 
 #if BX_SUPPORT_SB16
   if ( (channel != 2) && (channel != (unsigned) BX_SB16_DMAL) )
-    bx_panic("bx_dma_c::DRQ(): channel %d != 2 or %d (SB16) (\n",
+    bio->panic("[DMA] bx_dma_c::DRQ(): channel %d != 2 or %d (SB16) (\n",
 	     channel, BX_SB16_DMAL);
 #else
   if ( channel != 2 )
-    bx_panic("bx_dma_c::DRQ(): channel %d != 2\n",
+    bio->panic("[DMA] bx_dma_c::DRQ(): channel %d != 2\n",
 	     channel);
 #endif
   if (!val) {
-    //bx_printf("bx_dma_c::DRQ(): val == 0\n");
+    //bio->printf("[DMA] bx_dma_c::DRQ(): val == 0\n");
     // clear bit in status reg
     // deassert HRQ if not pending DRQ's ?
     // etc.
@@ -514,46 +517,46 @@ bx_dma_c::DRQ(unsigned channel, Boolean 
     }
 
 #if 0
-  bx_printf("BX_DMA_THIS s.mask[2]: %02x\n", (unsigned) BX_DMA_THIS s.mask[2]);
-  bx_printf("BX_DMA_THIS s.flip_flop: %u\n", (unsigned) BX_DMA_THIS s.flip_flop);
-  bx_printf("BX_DMA_THIS s.status_reg: %02x\n", (unsigned) BX_DMA_THIS s.status_reg);
-  bx_printf("mode_type: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.mode_type);
-  bx_printf("address_decrement: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.address_decrement);
-  bx_printf("autoinit_enable: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.autoinit_enable);
-  bx_printf("transfer_type: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.transfer_type);
-  bx_printf(".base_address: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_address);
-  bx_printf(".current_address: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].current_address);
-  bx_printf(".base_count: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_count);
-  bx_printf(".current_count: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].current_count);
-  bx_printf(".page_reg: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].page_reg);
+  bio->printf("[DMA] BX_DMA_THIS s.mask[2]: %02x\n", (unsigned) BX_DMA_THIS s.mask[2]);
+  bio->printf("[DMA] BX_DMA_THIS s.flip_flop: %u\n", (unsigned) BX_DMA_THIS s.flip_flop);
+  bio->printf("[DMA] BX_DMA_THIS s.status_reg: %02x\n", (unsigned) BX_DMA_THIS s.status_reg);
+  bio->printf("[DMA] mode_type: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.mode_type);
+  bio->printf("[DMA] address_decrement: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.address_decrement);
+  bio->printf("[DMA] autoinit_enable: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.autoinit_enable);
+  bio->printf("[DMA] transfer_type: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].mode.transfer_type);
+  bio->printf("[DMA] .base_address: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_address);
+  bio->printf("[DMA] .current_address: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].current_address);
+  bio->printf("[DMA] .base_count: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_count);
+  bio->printf("[DMA] .current_count: %04x\n", (unsigned) BX_DMA_THIS s.chan[channel].current_count);
+  bio->printf("[DMA] .page_reg: %02x\n", (unsigned) BX_DMA_THIS s.chan[channel].page_reg);
 #endif
 
   BX_DMA_THIS s.status_reg |= (1 << (channel+4));
 
   //  if (BX_DMA_THIS s.mask[channel])
-  //    bx_panic("bx_dma_c::DRQ(): BX_DMA_THIS s.mask[] is set\n");
+  //    bio->panic("[DMA] bx_dma_c::DRQ(): BX_DMA_THIS s.mask[] is set\n");
 
 
   if ( (BX_DMA_THIS s.chan[channel].mode.mode_type != DMA_MODE_SINGLE) &&
        (BX_DMA_THIS s.chan[channel].mode.mode_type != DMA_MODE_DEMAND) )
-    bx_panic("bx_dma_c::DRQ: mode_type(%02x) not handled\n",
+    bio->panic("[DMA] bx_dma_c::DRQ: mode_type(%02x) not handled\n",
       (unsigned) BX_DMA_THIS s.chan[channel].mode.mode_type);
   if (BX_DMA_THIS s.chan[channel].mode.address_decrement != 0)
-    bx_panic("bx_dma_c::DRQ: address_decrement != 0\n");
+    bio->panic("[DMA] bx_dma_c::DRQ: address_decrement != 0\n");
   //if (BX_DMA_THIS s.chan[channel].mode.autoinit_enable != 0)
-  //  bx_panic("bx_dma_c::DRQ: autoinit_enable != 0\n");
+  //  bio->panic("[DMA] bx_dma_c::DRQ: autoinit_enable != 0\n");
 
   dma_base = (BX_DMA_THIS s.chan[channel].page_reg << 16) | BX_DMA_THIS s.chan[channel].base_address;
   dma_roof = dma_base + BX_DMA_THIS s.chan[channel].base_count;
   if ( (dma_base & 0xffff0000) != (dma_roof & 0xffff0000) ) {
-bx_printf("dma_base = %08x\n", (unsigned) dma_base);
-bx_printf("dma_base_count = %08x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_count);
-bx_printf("dma_roof = %08x\n", (unsigned) dma_roof);
-    bx_panic("dma: DMA request outside 64k boundary\n");
+bio->printf("[DMA] dma_base = %08x\n", (unsigned) dma_base);
+bio->printf("[DMA] dma_base_count = %08x\n", (unsigned) BX_DMA_THIS s.chan[channel].base_count);
+bio->printf("[DMA] dma_roof = %08x\n", (unsigned) dma_roof);
+    bio->panic("[DMA] DMA request outside 64k boundary\n");
     }
 
 
-  //bx_printf("DRQ set up for single mode, increment, auto-init disabled, write\n");
+  //bio->printf("[DMA] DRQ set up for single mode, increment, auto-init disabled, write\n");
   // should check mask register VS DREQ's in status register here?
   // assert Hold ReQuest line to CPU
   bx_pc_system.set_HRQ(1);
@@ -575,11 +578,11 @@ bx_dma_c::raise_HLDA(bx_pc_system_c *pc_
     }
   if (channel >= 4) {
 	// don't panic, just wait till they're unmasked
-    //    bx_panic("hlda: no unmasked requests\n");
+    //    bio->panic("[DMA] hlda: no unmasked requests\n");
     return;
     }
 
-  //bx_printf("hlda: OK in response to DRQ(%u)\n", (unsigned) channel);
+  //bio->printf("[DMA] hlda: OK in response to DRQ(%u)\n", (unsigned) channel);
   phy_addr = (BX_DMA_THIS s.chan[channel].page_reg << 16) |
              BX_DMA_THIS s.chan[channel].current_address;
 
@@ -609,7 +612,7 @@ bx_dma_c::raise_HLDA(bx_pc_system_c *pc_
     }
   else {
     // address decrement
-    bx_panic("hlda: decrement not implemented\n");
+    bio->panic("[DMA] hlda: decrement not implemented\n");
     }
 
   if (BX_DMA_THIS s.chan[channel].mode.transfer_type == 1) { // write
@@ -621,7 +624,7 @@ bx_dma_c::raise_HLDA(bx_pc_system_c *pc_
     pc_sys->dma_read8(phy_addr, channel);
     }
   else {
-    bx_panic("hlda: transfer_type of %u not handled\n",
+    bio->panic("[DMA] hlda: transfer_type of %u not handled\n",
       (unsigned) BX_DMA_THIS s.chan[channel].mode.transfer_type);
     }
 
