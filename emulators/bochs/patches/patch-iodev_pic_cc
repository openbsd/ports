$OpenBSD: patch-iodev_pic_cc,v 1.1 2001/02/02 16:59:11 todd Exp $
--- iodev/pic.cc.orig	Sat Mar 25 21:28:49 2000
+++ iodev/pic.cc	Thu Oct 19 10:53:07 2000
@@ -121,11 +121,11 @@ bx_pic_c::read(Bit32u address, unsigned 
   UNUSED(this_ptr);
 #endif // !BX_USE_PIC_SMF
   if (io_len > 1)
-    bx_panic("pic: io read from port %04x, len=%u\n", (unsigned) address,
+    bio->panic("[PIC] io read from port %04x, len=%u\n", (unsigned) address,
              (unsigned) io_len);
 
-  if (bx_dbg.pic)
-    bx_printf("pic: IO read from %04x\n", (unsigned) address);
+  if (bio->getdbg().pic)
+    bio->printf("[PIC] IO read from %04x\n", (unsigned) address);
 
   /*
    8259A PIC
@@ -134,41 +134,41 @@ bx_pic_c::read(Bit32u address, unsigned 
   switch (address) {
     case 0x20:
       if (BX_PIC_THIS s.master_pic.read_reg_select) { /* ISR */
-        if (bx_dbg.pic) bx_printf("pic: read master ISR = %02x\n",
+        if (bio->getdbg().pic) bio->printf("[PIC] read master ISR = %02x\n",
 	                  (unsigned) BX_PIC_THIS s.master_pic.isr);
 	return(BX_PIC_THIS s.master_pic.isr);
 	}
       else { /* IRR */
-        if (bx_dbg.pic) bx_printf("pic: read master IRR = %02x\n",
+        if (bio->getdbg().pic) bio->printf("[PIC] read master IRR = %02x\n",
 	                  (unsigned) BX_PIC_THIS s.master_pic.irr);
 	return(BX_PIC_THIS s.master_pic.irr);
 	}
       break;
     case 0x21:
-      if (bx_dbg.pic) bx_printf("pic: read master IMR = %02x\n",
+      if (bio->getdbg().pic) bio->printf("[PIC] read master IMR = %02x\n",
                         (unsigned) BX_PIC_THIS s.master_pic.imr);
       return(BX_PIC_THIS s.master_pic.imr);
       break;
     case 0xA0:
       if (BX_PIC_THIS s.slave_pic.read_reg_select) { /* ISR */
-        if (bx_dbg.pic) bx_printf("pic: read slave ISR = %02x\n",
+        if (bio->getdbg().pic) bio->printf("[PIC] read slave ISR = %02x\n",
                           (unsigned) BX_PIC_THIS s.slave_pic.isr);
 	return(BX_PIC_THIS s.slave_pic.isr);
 	}
       else { /* IRR */
-        if (bx_dbg.pic) bx_printf("pic: read slave IRR = %02x\n",
+        if (bio->getdbg().pic) bio->printf("[PIC] read slave IRR = %02x\n",
                           (unsigned) BX_PIC_THIS s.slave_pic.irr);
 	return(BX_PIC_THIS s.slave_pic.irr);
 	}
       break;
     case 0xA1:
-      if (bx_dbg.pic) bx_printf("pic: read slave IMR = %02x\n",
+      if (bio->getdbg().pic) bio->printf("[PIC] read slave IMR = %02x\n",
                         (unsigned) BX_PIC_THIS s.slave_pic.imr);
       return(BX_PIC_THIS s.slave_pic.imr);
       break;
     }
 
-  bx_panic("pic: io read to address %04x\n", (unsigned) address);
+  bio->panic("[PIC] io read to address %04x\n", (unsigned) address);
   return(0); /* default if not found above */
 }
 
@@ -194,11 +194,11 @@ bx_pic_c::write(Bit32u address, Bit32u v
   int irq;
 
   if (io_len > 1)
-    bx_panic("pic: io write to port %04x, len=%u\n", (unsigned) address,
+    bio->panic("[PIC] io write to port %04x, len=%u\n", (unsigned) address,
              (unsigned) io_len);
 
-  if (bx_dbg.pic)
-    bx_printf("pic: IO write to %04x = %02x\n",
+  if (bio->getdbg().pic)
+    bio->printf("[PIC] IO write to %04x = %02x\n",
       (unsigned) address, (unsigned) value);
 
   /*
@@ -209,12 +209,12 @@ bx_pic_c::write(Bit32u address, Bit32u v
     case 0x20:
       if (value & 0x10) { /* initialization command 1 */
 	    // (mch) Ignore...
-	    // bx_printf("pic:master: init command 1 found %02x\n", (unsigned) value);
-        if (bx_dbg.pic) {
-          bx_printf("pic:master: init command 1 found\n");
-          bx_printf("            requires 4 = %u\n",
+	    // bio->printf("[PIC] master: init command 1 found %02x\n", (unsigned) value);
+        if (bio->getdbg().pic) {
+          bio->printf("[PIC] master: init command 1 found\n");
+          bio->printf("[PIC]            requires 4 = %u\n",
             (unsigned) (value & 0x01) );
-          bx_printf("            cascade mode: [0=cascade,1=single] %u\n",
+          bio->printf("[PIC]            cascade mode: [0=cascade,1=single] %u\n",
             (unsigned) ((value & 0x02) >> 1));
           }
         BX_PIC_THIS s.master_pic.init.in_init = 1;
@@ -225,7 +225,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
         BX_PIC_THIS s.master_pic.irr           = 0x00; /* no IRQ's requested */
         BX_PIC_THIS s.master_pic.INT = 0; /* reprogramming clears previous INTR request */
         if ( (value & 0x02) == 1 )
-          bx_panic("pic:master: init command: single mode\n");
+          bio->panic("[PIC] master: init command: single mode\n");
         BX_SET_INTR(0);
         return;
         }
@@ -237,7 +237,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
         poll         = (value & 0x04) >> 2;
         read_op      = (value & 0x03);
         if (poll)
-          bx_panic("pic:master:OCW3: poll bit set\n");
+          bio->panic("[PIC] master:OCW3: poll bit set\n");
         if (read_op == 0x02) /* read IRR */
 	  BX_PIC_THIS s.master_pic.read_reg_select = 0;
         else if (read_op == 0x03) /* read ISR */
@@ -255,7 +255,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
       /* OCW2 */
       switch (value) {
         case 0x00: // Rotate in Auto-EOI mode
-          bx_panic("PIC: Rotate in Auto-EOI mode command received.\n");
+          bio->panic("[PIC] Rotate in Auto-EOI mode command received.\n");
 	case 0x0A: /* select read interrupt request register */
 	  BX_PIC_THIS s.master_pic.read_reg_select = 0;
 	  break;
@@ -296,11 +296,11 @@ bx_pic_c::write(Bit32u address, Bit32u v
         case 0xC6: // 6 5 4 3 2 1 0 7
         case 0xC7: // 7 6 5 4 3 2 1 0
           // ignore for now
-          bx_printf("pic: IRQ lowest command 0x%x\n", value);
+          bio->printf("[PIC] IRQ lowest command 0x%x\n", value);
           break;
 
         default:
-          bx_panic("PIC: write to port 20h = %02x\n", value);
+          bio->panic("[PIC] write to port 20h = %02x\n", value);
 	} /* switch (value) */
       break;
 
@@ -311,16 +311,16 @@ bx_pic_c::write(Bit32u address, Bit32u v
           case 2:
             BX_PIC_THIS s.master_pic.interrupt_offset = value & 0xf8;
             BX_PIC_THIS s.master_pic.init.byte_expected = 3;
-	    if (bx_dbg.pic) {
-		  bx_printf("pic:master: init command 2 = %02x\n", (unsigned) value);
-		  bx_printf("            offset = INT %02x\n",
+	    if (bio->getdbg().pic) {
+		  bio->printf("[PIC] master: init command 2 = %02x\n", (unsigned) value);
+		  bio->printf("[PIC]            offset = INT %02x\n",
 			    BX_PIC_THIS s.master_pic.interrupt_offset);
 	    }
             return;
             break;
           case 3:
-	    if (bx_dbg.pic)
-		  bx_printf("pic:master: init command 3 = %02x\n", (unsigned) value);
+	    if (bio->getdbg().pic)
+		  bio->printf("[PIC] master: init command 3 = %02x\n", (unsigned) value);
             if (BX_PIC_THIS s.master_pic.init.requires_4) {
               BX_PIC_THIS s.master_pic.init.byte_expected = 4;
 	      }
@@ -330,27 +330,27 @@ bx_pic_c::write(Bit32u address, Bit32u v
             return;
             break;
           case 4:
-	    if (bx_dbg.pic) {
-		  bx_printf("pic:master: init command 4 = %02x\n", (unsigned) value);
-		  if (value & 0x02) bx_printf("pic:        auto EOI\n");
-		  else bx_printf("pic: normal EOI interrupt\n");
+	    if (bio->getdbg().pic) {
+		  bio->printf("[PIC] master: init command 4 = %02x\n", (unsigned) value);
+		  if (value & 0x02) bio->printf("[PIC]        auto EOI\n");
+		  else bio->printf("[PIC] normal EOI interrupt\n");
 	    }
 	    if (value & 0x01) {
-		  if (bx_dbg.pic)
-			bx_printf("pic:        80x86 mode\n");
+		  if (bio->getdbg().pic)
+			bio->printf("[PIC]        80x86 mode\n");
 	    } else
-		  bx_panic("pic:        not 80x86 mode\n");
+		  bio->panic("[PIC]        not 80x86 mode\n");
             BX_PIC_THIS s.master_pic.init.in_init = 0;
             return;
             break;
           default:
-            bx_panic("pic:master expecting bad init command\n");
+            bio->panic("[PIC] master expecting bad init command\n");
           }
         }
 
       /* normal operation */
-      if (bx_dbg.pic)
-        bx_printf("pic: setting master pic IMR to %02x\n", value);
+      if (bio->getdbg().pic)
+        bio->printf("[PIC] setting master pic IMR to %02x\n", value);
       BX_PIC_THIS s.master_pic.imr = value;
       service_master_pic();
       return;
@@ -358,11 +358,11 @@ bx_pic_c::write(Bit32u address, Bit32u v
 
     case 0xA0:
       if (value & 0x10) { /* initialization command 1 */
-        if (bx_dbg.pic) {
-          bx_printf("pic:slave: init command 1 found\n");
-          bx_printf("           requires 4 = %u\n",
+        if (bio->getdbg().pic) {
+          bio->printf("[PIC] slave: init command 1 found\n");
+          bio->printf("[PIC]           requires 4 = %u\n",
             (unsigned) (value & 0x01) );
-          bx_printf("           cascade mode: [0=cascade,1=single] %u\n",
+          bio->printf("[PIC]           cascade mode: [0=cascade,1=single] %u\n",
             (unsigned) ((value & 0x02) >> 1));
           }
         BX_PIC_THIS s.slave_pic.init.in_init = 1;
@@ -373,7 +373,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
         BX_PIC_THIS s.slave_pic.irr           = 0x00; /* no IRQ's requested */
         BX_PIC_THIS s.slave_pic.INT = 0; /* reprogramming clears previous INTR request */
         if ( (value & 0x02) == 1 )
-          bx_panic("pic:slave: init command: single mode\n");
+          bio->panic("[PIC] slave: init command: single mode\n");
         return;
         }
 
@@ -384,7 +384,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
         poll         = (value & 0x04) >> 2;
         read_op      = (value & 0x03);
         if (poll)
-          bx_panic("pic:slave:OCW3: poll bit set\n");
+          bio->panic("[PIC] slave:OCW3: poll bit set\n");
         if (read_op == 0x02) /* read IRR */
 	  BX_PIC_THIS s.slave_pic.read_reg_select = 0;
         else if (read_op == 0x03) /* read ISR */
@@ -395,7 +395,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
         else if (special_mask == 0x03) { /* set specific mask */
           BX_PIC_THIS s.slave_pic.special_mask = 1;
           service_slave_pic();
-          bx_printf("pic:slave: OCW3 not implemented (%02x)\n",
+          bio->printf("[PIC] slave: OCW3 not implemented (%02x)\n",
             (unsigned) value);
           }
         return;
@@ -432,7 +432,7 @@ bx_pic_c::write(Bit32u address, Bit32u v
 	  break;
 
         default:
-          bx_panic("PIC: write to port A0h = %02x\n", value);
+          bio->panic("[PIC] write to port A0h = %02x\n", value);
 	} /* switch (value) */
       break;
 
@@ -443,16 +443,16 @@ bx_pic_c::write(Bit32u address, Bit32u v
           case 2:
             BX_PIC_THIS s.slave_pic.interrupt_offset = value & 0xf8;
             BX_PIC_THIS s.slave_pic.init.byte_expected = 3;
-	    if (bx_dbg.pic) {
-		  bx_printf("pic:slave: init command 2 = %02x\n", (unsigned) value);
-		  bx_printf("           offset = INT %02x\n",
+	    if (bio->getdbg().pic) {
+		  bio->printf("[PIC] slave: init command 2 = %02x\n", (unsigned) value);
+		  bio->printf("[PIC]           offset = INT %02x\n",
 			    BX_PIC_THIS s.slave_pic.interrupt_offset);
 	    }
             return;
             break;
           case 3:
-		if (bx_dbg.pic)
-		      bx_printf("pic:slave: init command 3 = %02x\n", (unsigned) value);
+		if (bio->getdbg().pic)
+		      bio->printf("[PIC] slave: init command 3 = %02x\n", (unsigned) value);
             if (BX_PIC_THIS s.slave_pic.init.requires_4) {
               BX_PIC_THIS s.slave_pic.init.byte_expected = 4;
 	      }
@@ -462,26 +462,26 @@ bx_pic_c::write(Bit32u address, Bit32u v
             return;
             break;
           case 4:
-		if (bx_dbg.pic) {
-		      bx_printf("pic:slave: init command 4 = %02x\n", (unsigned) value);
-		      if (value & 0x02) bx_printf("pic:       auto EOI\n");
-		      else bx_printf("pic: normal EOI interrupt\n");
+		if (bio->getdbg().pic) {
+		      bio->printf("[PIC] slave: init command 4 = %02x\n", (unsigned) value);
+		      if (value & 0x02) bio->printf("[PIC]       auto EOI\n");
+		      else bio->printf("[PIC] normal EOI interrupt\n");
 		}
 		if (value & 0x01) {
-		      if (bx_dbg.pic)
-			    bx_printf("pic:       80x86 mode\n");
-		} else bx_panic("pic: not 80x86 mode\n");
+		      if (bio->getdbg().pic)
+			    bio->printf("[PIC]       80x86 mode\n");
+		} else bio->panic("[PIC] not 80x86 mode\n");
             BX_PIC_THIS s.slave_pic.init.in_init = 0;
             return;
             break;
           default:
-            bx_panic("pic:slave: expecting bad init command\n");
+            bio->panic("[PIC] slave: expecting bad init command\n");
           }
         }
 
       /* normal operation */
-      if (bx_dbg.pic)
-        bx_printf("pic: setting slave pic IMR to %02x\n", value);
+      if (bio->getdbg().pic)
+        bio->printf("[PIC] setting slave pic IMR to %02x\n", value);
       BX_PIC_THIS s.slave_pic.imr = value;
       service_slave_pic();
       return;
@@ -498,11 +498,11 @@ bx_pic_c::trigger_irq(unsigned irq_no)
 
 #if BX_DEBUG
   if ( irq_no > 15 )
-    bx_panic("trigger_irq: irq out of range\n");
+    bio->panic("[PIC] trigger_irq: irq out of range\n");
 #endif
 
-  if (bx_dbg.pic)
-    bx_printf("trigger_irq(%d decimal)\n", (unsigned) irq_no);
+  if (bio->getdbg().pic)
+    bio->printf("[PIC] trigger_irq(%d decimal)\n", (unsigned) irq_no);
 
   if (irq_no <= 7) {
     irq_no_bitmask = 1 << irq_no;
@@ -523,11 +523,11 @@ bx_pic_c::untrigger_irq(unsigned irq_no)
 
 #if BX_DEBUG
   if ( irq_no > 15 )
-    bx_panic("untrigger_irq: irq out of range\n");
+    bio->panic("[PIC] untrigger_irq: irq out of range\n");
 #endif
 
-  if (bx_dbg.pic)
-    bx_printf("untrigger_irq(%d decimal)\n", (unsigned) irq_no);
+  if (bio->getdbg().pic)
+    bio->printf("[PIC] untrigger_irq(%d decimal)\n", (unsigned) irq_no);
 
   if (irq_no <= 7) {
     irq_no_bitmask = 1 << irq_no;
@@ -571,7 +571,7 @@ bx_pic_c::service_master_pic(void)
         max_irq++;
         }
       if (max_irq == 0 ) return; /* IRQ0 in-service, no other priorities allowed */
-      if (max_irq > 7) bx_panic("error in service_master_pic()\n");
+      if (max_irq > 7) bio->panic("[PIC] error in service_master_pic()\n");
       }
     else
       max_irq = 7; /* 0..7 bits in ISR are cleared */
@@ -587,8 +587,8 @@ bx_pic_c::service_master_pic(void)
       if ( BX_PIC_THIS s.master_pic.special_mask && ((BX_PIC_THIS s.master_pic.isr >> irq) & 0x01) )
         continue;
       if (unmasked_requests & (1 << irq)) {
-        if (bx_dbg.pic)
-          bx_printf("pic: signalling IRQ(%u)\n",
+        if (bio->getdbg().pic)
+          bio->printf("[PIC] signalling IRQ(%u)\n",
             (unsigned) irq);
         BX_PIC_THIS s.master_pic.irr &= ~(1 << irq);
         /*??? do for slave too: BX_PIC_THIS s.master_pic.isr |=  (1 << irq);*/
@@ -621,7 +621,7 @@ bx_pic_c::service_slave_pic(void)
       isr >>= 1;
       lowest_priority_irq++;
       }
-    if (lowest_priority_irq > 7) bx_panic("error in service_slave_pic()\n");
+    if (lowest_priority_irq > 7) bio->panic("[PIC] error in service_slave_pic()\n");
     }
   else
     lowest_priority_irq = 8;
@@ -631,8 +631,8 @@ bx_pic_c::service_slave_pic(void)
   if ((unmasked_requests = (BX_PIC_THIS s.slave_pic.irr & ~BX_PIC_THIS s.slave_pic.imr)) ) {
     for (irq=0; irq<lowest_priority_irq; irq++) {
       if (unmasked_requests & (1 << irq)) {
-        if (bx_dbg.pic)
-          bx_printf("pic(slave): signalling IRQ(%u)\n",
+        if (bio->getdbg().pic)
+          bio->printf("pic(slave): signalling IRQ(%u)\n",
             (unsigned) 8 + irq);
         BX_PIC_THIS s.slave_pic.irr &= ~(1 << irq);
         BX_PIC_THIS s.slave_pic.INT = 1;
@@ -681,8 +681,8 @@ bx_pic_c::IAC(void)
   void
 bx_pic_c::show_pic_state(void)
 {
-bx_printf("s.master_pic.imr = %02x\n", BX_PIC_THIS s.master_pic.imr);
-bx_printf("s.master_pic.isr = %02x\n", BX_PIC_THIS s.master_pic.isr);
-bx_printf("s.master_pic.irr = %02x\n", BX_PIC_THIS s.master_pic.irr);
-bx_printf("s.master_pic.irq = %02x\n", BX_PIC_THIS s.master_pic.irq);
+bio->printf("[PIC] s.master_pic.imr = %02x\n", BX_PIC_THIS s.master_pic.imr);
+bio->printf("[PIC] s.master_pic.isr = %02x\n", BX_PIC_THIS s.master_pic.isr);
+bio->printf("[PIC] s.master_pic.irr = %02x\n", BX_PIC_THIS s.master_pic.irr);
+bio->printf("[PIC] s.master_pic.irq = %02x\n", BX_PIC_THIS s.master_pic.irq);
 }
