$OpenBSD: patch-bin_fnrancid_in,v 1.1.1.1 2008/12/16 21:07:55 pea Exp $
--- bin/fnrancid.in.orig	Sun Jan 11 04:49:13 2004
+++ bin/fnrancid.in	Tue Dec 16 15:40:23 2008
@@ -1,8 +1,9 @@
 #! @PERLV_PATH@
 ##
-## $Id: patch-bin_fnrancid_in,v 1.1.1.1 2008/12/16 21:07:55 pea Exp $
+## $Id: patch-bin_fnrancid_in,v 1.1.1.1 2008/12/16 21:07:55 pea Exp $
 ##
-## Copyright (C) 1997-2004 by Terrapin Communications, Inc.
+## rancid 2.3.2a7
+## Copyright (C) 1997-2006 by Terrapin Communications, Inc.
 ## All rights reserved.
 ##
 ## This software may be freely copied, modified and redistributed
@@ -20,11 +21,11 @@
 ##
 #
 # A library built on Stephen Gill's Netscreen stuff to accomodate
-#  the Fortinet product line.  [d_pfleger@juniper.net] 
+#  the Fortinet product line.  [d_pfleger@juniper.net]
 #
 #  RANCID - Really Awesome New Cisco confIg Differ
 #
-# usage: rancid [-d] [-l] [-f filename | $host]
+# usage: rancid [-dV] [-l] [-f filename | hostname]
 #
 use Getopt::Std;
 getopts('dfl');
@@ -34,15 +35,16 @@ $debug = $opt_d;
 $file = $opt_f;
 $host = $ARGV[0];
 $found_end = 0;
-$timeo = 90;			# nlogin timeout in seconds
+$timeo = 90;				# fnlogin timeout in seconds
 
-my(%filter_pwds);		# password filtering mode
+my(@commandtable, %commands, @commands);# command lists
+my(%filter_pwds);			# password filtering mode
 
 # This routine is used to print out the router configuration
 sub ProcessHistory {
-    my($new_hist_tag,$new_command,$command_string,@string)=(@_);
-    if((($new_hist_tag ne $hist_tag) || ($new_command ne $command))
-       && defined %history) {
+    my($new_hist_tag,$new_command,$command_string,@string) = (@_);
+    if ((($new_hist_tag ne $hist_tag) || ($new_command ne $command))
+	&& defined %history) {
 	print eval "$command \%history";
 	undef %history;
     }
@@ -64,10 +66,10 @@ sub ProcessHistory {
 
 sub numerically { $a <=> $b; }
 
-# This is a sort routing that will sort numerically on the
+# This is a sort routine that will sort numerically on the
 # keys of a hash as if it were a normal array.
 sub keynsort {
-    local(%lines)=@_;
+    local(%lines) = @_;
     local($i) = 0;
     local(@sorted_lines);
     foreach $key (sort numerically keys(%lines)) {
@@ -77,10 +79,10 @@ sub keynsort {
     @sorted_lines;
 }
 
-# This is a sort routing that will sort on the
+# This is a sort routine that will sort on the
 # keys of a hash as if it were a normal array.
 sub keysort {
-    local(%lines)=@_;
+    local(%lines) = @_;
     local($i) = 0;
     local(@sorted_lines);
     foreach $key (sort keys(%lines)) {
@@ -90,22 +92,22 @@ sub keysort {
     @sorted_lines;
 }
 
-# This is a sort routing that will sort on the
+# This is a sort routine that will sort on the
 # values of a hash as if it were a normal array.
 sub valsort{
-    local(%lines)=@_;
+    local(%lines) = @_;
     local($i) = 0;
     local(@sorted_lines);
     foreach $key (sort values %lines) {
-        $sorted_lines[$i] = $key;
-        $i++;
+	$sorted_lines[$i] = $key;
+	$i++;
     }
     @sorted_lines;
 }
 
-# This is a numerical sort routing (ascending).
+# This is a numerical sort routine (ascending).
 sub numsort {
-    local(%lines)=@_;
+    local(%lines) = @_;
     local($i) = 0;
     local(@sorted_lines);
     foreach $num (sort {$a <=> $b} keys %lines) {
@@ -119,7 +121,7 @@ sub numsort {
 # ip address when the ip address is anywhere in
 # the strings.
 sub ipsort {
-    local(%lines)=@_;
+    local(%lines) = @_;
     local($i) = 0;
     local(@sorted_lines);
     foreach $addr (sort sortbyipaddr keys %lines) {
@@ -132,7 +134,7 @@ sub ipsort {
 # These two routines will sort based upon IP addresses
 sub ipaddrval {
     my(@a) = ($_[0] =~ m#^(\d+)\.(\d+)\.(\d+)\.(\d+)$#);
-    $a[3]+256*($a[2]+256*($a[1]+256*$a[0]));
+    $a[3] + 256 * ($a[2] + 256 * ($a[1] +256 * $a[0]));
 }
 sub sortbyipaddr {
     &ipaddrval($a) <=> &ipaddrval($b);
@@ -146,7 +148,7 @@ sub GetSystem {
 	tr/\015//d;
 	next if /^\s*$/;
 	last if(/$prompt/);
-	ProcessHistory("","","","$_"); 
+	ProcessHistory("","","","!$_");
 	#print STDOUT "$_";
     }
     print STDOUT "Vendor: $vendor";
@@ -167,12 +169,11 @@ sub GetConf {
     print STDERR "    In GetConf: $_" if ($debug);
     while (<INPUT>) {
 	tr/\015//d;
-	next if /^\s*$/;
 	last if(/$prompt/);
 	if (/(^set.*)('Enc .*')(.*)/) {
-            ProcessHistory("ENC","","","!$1 'Enc **encoding removed**' $3\n");
-            next;
-        }
+	    ProcessHistory("ENC","","","!$1 'Enc **encoding removed**' $3\n");
+	    next;
+	}
 	ProcessHistory("","","","$_");
 	#print STDOUT "$_";
     }
@@ -184,19 +185,27 @@ sub GetConf {
 sub DoNothing {print STDOUT;}
 
 # Main
-%commands=(
-	'get system status'	=> "GetSystem",
-	'get conf'		=> "GetConf"
+@commandtable = (
+	{'get system status'	=> 'GetSystem'},
+	{'show'		=> 'GetConf'}
 );
-# keys() doesnt return things in the order entered and the order of the
-# cmds is important. pita
-@commands=(
-	"get system status",
-	"get conf"
-);
+# Use an array to preserve the order of the commands and a hash for mapping
+# commands to the subroutine and track commands that have been completed.
+@commands = map(keys(%$_), @commandtable);
+%commands = map(%$_, @commandtable);
+
 $cisco_cmds=join(";",@commands);
 $cmds_regexp=join("|",@commands);
 
+if (length($host) == 0) {
+    if ($file) {
+	print(STDERR "Too few arguments: file name required\n");
+	exit(1);
+    } else {
+	print(STDERR "Too few arguments: host name required\n");
+	exit(1);
+    }
+}
 open(OUTPUT,">$host.new") || die "Can't open $host.new for writing: $!\n";
 select(OUTPUT);
 # make OUTPUT unbuffered if debugging
@@ -206,19 +215,19 @@ if ($file) {
     print STDERR "opening file $host\n" if ($debug);
     print STDOUT "opening file $host\n" if ($log);
     open(INPUT,"<$host") || die "open failed for $host: $!\n"; } else {
-    print STDERR "executing nlogin -t $timeo -c\"$cisco_cmds\" $host\n" if ($debug);
-    print STDOUT "executing nlogin -t $timeo -c\"$cisco_cmds\" $host\n" if ($log);
+    print STDERR "executing fnlogin -t $timeo -c\"$cisco_cmds\" $host\n" if ($debug);
+    print STDOUT "executing fnlogin -t $timeo -c\"$cisco_cmds\" $host\n" if ($log);
     if (defined($ENV{NOPIPE})) {
-	system "nlogin -t $timeo -c \"$cisco_cmds\" $host </dev/null > $host.raw 2>&1" || die "nlogin failed for $host: $!\n";
+	system "fnlogin -t $timeo -c \"$cisco_cmds\" $host </dev/null > $host.raw 2>&1" || die "nlogin failed for $host: $!\n";
 	open(INPUT, "< $host.raw") || die "nlogin failed for $host: $!\n";
     } else {
-	open(INPUT,"nlogin -t $timeo -c \"$cisco_cmds\" $host </dev/null |") || die "nlogin failed for $host: $!\n";
+	open(INPUT,"fnlogin -t $timeo -c \"$cisco_cmds\" $host </dev/null |") || die "nlogin failed for $host: $!\n";
     }
 }
 
 # determine password filtering mode
 if ($ENV{"FILTER_PWDS"} =~ /no/i) {
-	$filter_pwds = 0;  
+	$filter_pwds = 0;
 } elsif ($ENV{"FILTER_PWDS"} =~ /all/i) {
 	$filter_pwds = 2;
 } else {
@@ -229,13 +238,32 @@ ProcessHistory("","","","!RANCID-CONTENT-TYPE: Fortiga
 TOP: while(<INPUT>) {
     tr/\015//d;
     if (/^Error:/) {
-	print STDOUT ("$host nlogin error: $_");
-	print STDERR ("$host nlogin error: $_") if ($debug);
+	print STDOUT ("$host fnlogin error: $_");
+	print STDERR ("$host fnlogin error: $_") if ($debug);
 	last;
     }
-    while (/>\s*($cmds_regexp)\s*$/) {
-	$cmd = $1;
-	if (!defined($prompt)) { $prompt = " >\s*"; }
+    while (/^.+(#|\$)\s*($cmds_regexp)\s*$/) {
+		$cmd = $2;
+		# - FortiGate prompts end with either '#' or '$'. Further, they may
+# be prepended with a '~' if the hostname is too long. Therefore, 
+# we need to figure out what our prompt really is.
+		if (!defined($prompt)) {
+		    if ( $_ =~ m/^.+\~\$/ ) {
+			$prompt = '\~\$ .*' ;
+		    } else {
+			if ( $_ =~ m/^.+\$/ ) {
+			    $prompt = ' \$ .*' ;
+			} else {
+			    if ( $_ =~ m/^.+\~#/ ) {
+				 $prompt = '\~# .*' ;
+			     } else {
+				 if ( $_ =~ m/^.+#/ ) {
+				      $prompt = ' # .*' ;
+				  }
+			     }
+			}
+		    }
+		}
 	print STDERR ("HIT COMMAND:$_") if ($debug);
 	if (!defined($commands{$cmd})) {
 	    print STDERR "$host: found unexpected command - \"$cmd\"\n";
