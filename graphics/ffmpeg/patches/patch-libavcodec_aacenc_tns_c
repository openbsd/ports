$OpenBSD: patch-libavcodec_aacenc_tns_c,v 1.1 2015/09/15 12:49:42 ajacoutot Exp $

aacenc_tns: redo coefficient quantization and decision making

aacenc_tns: encode coefficients directly and reenable compression

--- libavcodec/aacenc_tns.c.orig	Sat Sep 12 15:01:30 2015
+++ libavcodec/aacenc_tns.c	Sat Sep 12 15:02:10 2015
@@ -31,17 +31,34 @@
 #include "aacenc_utils.h"
 #include "aacenc_quantization.h"
 
+/*
+ * Shifts the values as well if compression is possible.
+ */
+static inline int compress_coeffs(int *coef, int order, int c_bits)
+{
+    int i, res = 0;
+    const int low_idx   = c_bits ?  4 : 2;
+    const int shift_val = c_bits ?  8 : 4;
+    const int high_idx  = c_bits ? 11 : 5;
+    for (i = 0; i < order; i++)
+        if (coef[i] < low_idx && coef[i] > high_idx)
+            res++;
+    if (res == order)
+        for (i = 0; i < order; i++)
+            coef[i] -= (coef[i] > high_idx) ? shift_val : 0;
+    return res == order;
+}
+
 /**
  * Encode TNS data.
  * Coefficient compression saves a single bit per coefficient.
  */
 void ff_aac_encode_tns_info(AACEncContext *s, SingleChannelElement *sce)
 {
-    uint8_t u_coef;
-    const uint8_t coef_res = TNS_Q_BITS == 4;
     int i, w, filt, coef_len, coef_compress = 0;
     const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;
     TemporalNoiseShaping *tns = &sce->tns;
+    const int c_bits = is8 ? TNS_Q_BITS_SHORT == 4 : TNS_Q_BITS == 4;
 
     if (!sce->tns.present)
         return;
@@ -49,38 +66,24 @@ void ff_aac_encode_tns_info(AACEncContext *s, SingleCh
     for (i = 0; i < sce->ics.num_windows; i++) {
         put_bits(&s->pb, 2 - is8, sce->tns.n_filt[i]);
         if (tns->n_filt[i]) {
-            put_bits(&s->pb, 1, coef_res);
+            put_bits(&s->pb, 1, c_bits);
             for (filt = 0; filt < tns->n_filt[i]; filt++) {
                 put_bits(&s->pb, 6 - 2 * is8, tns->length[i][filt]);
                 put_bits(&s->pb, 5 - 2 * is8, tns->order[i][filt]);
                 if (tns->order[i][filt]) {
+                    coef_compress = compress_coeffs(tns->coef_idx[i][filt],
+                                                    tns->order[i][filt], c_bits);
                     put_bits(&s->pb, 1, !!tns->direction[i][filt]);
                     put_bits(&s->pb, 1, !!coef_compress);
-                    coef_len = coef_res + 3 - coef_compress;
-                    for (w = 0; w < tns->order[i][filt]; w++) {
-                        u_coef = (tns->coef_idx[i][filt][w])&(~(~0<<coef_len));
-                        put_bits(&s->pb, coef_len, u_coef);
-                    }
+                    coef_len = c_bits + 3 - coef_compress;
+                    for (w = 0; w < tns->order[i][filt]; w++)
+                        put_bits(&s->pb, coef_len, tns->coef_idx[i][filt][w]);
                 }
             }
         }
     }
 }
 
-static inline void quantize_coefs(double *coef, int *idx, float *lpc, int order)
-{
-    int i;
-    uint8_t u_coef;
-    const float *quant_arr = tns_tmp2_map[TNS_Q_BITS == 4];
-    const double iqfac_p = ((1 << (TNS_Q_BITS-1)) - 0.5)/(M_PI/2.0);
-    const double iqfac_m = ((1 << (TNS_Q_BITS-1)) + 0.5)/(M_PI/2.0);
-    for (i = 0; i < order; i++) {
-        idx[i] = ceilf(asin(coef[i])*((coef[i] >= 0) ? iqfac_p : iqfac_m));
-        u_coef = (idx[i])&(~(~0<<TNS_Q_BITS));
-        lpc[i] = quant_arr[u_coef];
-    }
-}
-
 /* Apply TNS filter */
 void ff_aac_apply_tns(AACEncContext *s, SingleChannelElement *sce)
 {
@@ -122,22 +125,41 @@ void ff_aac_apply_tns(AACEncContext *s, SingleChannelE
     }
 }
 
+/*
+ * c_bits - 1 if 4 bit coefficients, 0 if 3 bit coefficients
+ */
+static inline void quantize_coefs(double *coef, int *idx, float *lpc, int order,
+                                  int c_bits)
+{
+    int i;
+    const float *quant_arr = tns_tmp2_map[c_bits];
+    for (i = 0; i < order; i++) {
+        idx[i] = quant_array_idx((float)coef[i], quant_arr, c_bits ? 16 : 8);
+        lpc[i] = quant_arr[idx[i]];
+    }
+}
+
+/*
+ * 3 bits per coefficient with 8 short windows
+ */
 void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)
 {
     TemporalNoiseShaping *tns = &sce->tns;
     int w, w2, g, count = 0;
     const int mmm = FFMIN(sce->ics.tns_max_bands, sce->ics.max_sfb);
     const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;
-    const int order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;
+    const int c_bits = is8 ? TNS_Q_BITS_SHORT == 4 : TNS_Q_BITS == 4;
 
     int sfb_start = av_clip(tns_min_sfb[is8][s->samplerate_index], 0, mmm);
     int sfb_end   = av_clip(sce->ics.num_swb, 0, mmm);
 
     for (w = 0; w < sce->ics.num_windows; w++) {
-        float e_ratio = 0.0f, threshold = 0.0f, spread = 0.0f, en[2] = {0.0, 0.0f};
-        double gain = 0.0f, coefs[MAX_LPC_ORDER] = {0};
+        int use_tns;
+        int order = is8 ? 5 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;
         int coef_start = w*sce->ics.num_swb + sce->ics.swb_offset[sfb_start];
         int coef_len = sce->ics.swb_offset[sfb_end] - sce->ics.swb_offset[sfb_start];
+        float e_ratio = 0.0f, threshold = 0.0f, spread = 0.0f, en[2] = {0.0, 0.0f};
+        double gain = 0.0f, coefs[MAX_LPC_ORDER] = {0};
 
         for (g = 0;  g < sce->ics.num_swb; g++) {
             if (w*16+g < sfb_start || w*16+g > sfb_end)
@@ -149,22 +171,26 @@ void ff_aac_search_for_tns(AACEncContext *s, SingleCha
                 else
                     en[0] += band->energy;
                 threshold += band->threshold;
-                spread += band->spread;
+                spread    += band->spread;
             }
         }
 
         if (coef_len <= 0 || (sfb_end - sfb_start) <= 0)
             continue;
-        else
-            e_ratio = en[0]/en[1];
 
         /* LPC */
         gain = ff_lpc_calc_ref_coefs_f(&s->lpc, &sce->coeffs[coef_start],
                                        coef_len, order, coefs);
 
-        if (gain > TNS_GAIN_THRESHOLD_LOW && gain < TNS_GAIN_THRESHOLD_HIGH &&
-            (en[0]+en[1]) > TNS_GAIN_THRESHOLD_LOW*threshold &&
-            spread < TNS_SPREAD_THRESHOLD && order) {
+        if (!order || gain < TNS_GAIN_THRESHOLD_LOW || gain > TNS_GAIN_THRESHOLD_HIGH)
+            use_tns = 0;
+        else if ((en[0]+en[1]) < TNS_GAIN_THRESHOLD_LOW*threshold || spread < TNS_SPREAD_THRESHOLD)
+            use_tns = 0;
+        else
+            use_tns = 1;
+
+        if (use_tns) {
+            e_ratio = en[0]/en[1];
             if (is8 || order < 2 || (e_ratio > TNS_E_RATIO_LOW && e_ratio < TNS_E_RATIO_HIGH)) {
                 tns->n_filt[w] = 1;
                 for (g = 0; g < tns->n_filt[w]; g++) {
@@ -172,7 +198,7 @@ void ff_aac_search_for_tns(AACEncContext *s, SingleCha
                     tns->direction[w][g] = en[0] < en[1];
                     tns->order[w][g] = order;
                     quantize_coefs(coefs, tns->coef_idx[w][g], tns->coef[w][g],
-                                   order);
+                                   order, c_bits);
                 }
             } else {  /* 2 filters due to energy disbalance */
                 tns->n_filt[w] = 2;
@@ -183,12 +209,11 @@ void ff_aac_search_for_tns(AACEncContext *s, SingleCha
                                     (sfb_end - sfb_start) - tns->length[w][g-1];
                     quantize_coefs(&coefs[!g ? 0 : order - tns->order[w][g-1]],
                                    tns->coef_idx[w][g], tns->coef[w][g],
-                                   tns->order[w][g]);
+                                   tns->order[w][g], c_bits);
                 }
             }
             count++;
         }
     }
-
     sce->tns.present = !!count;
 }
