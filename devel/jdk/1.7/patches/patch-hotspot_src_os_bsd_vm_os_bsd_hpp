$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_hpp,v 1.4 2009/01/04 23:25:16 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.hpp.orig	Wed Dec 24 10:02:07 2008
+++ hotspot/src/os/bsd/vm/os_bsd.hpp	Wed Dec 24 10:04:07 2008
@@ -47,6 +47,7 @@ class Bsd {
   static int sigflags[MAXSIGNUM];
 
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+#ifndef _ALLBSD_SOURCE
   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 
   static address   _initial_thread_stack_bottom;
@@ -58,6 +59,7 @@ class Bsd {
   static bool _is_floating_stack;
   static bool _is_NPTL;
   static bool _supports_fast_thread_cpu_time;
+#endif
 
   static GrowableArray<int>* _cpu_to_node;
 
@@ -65,38 +67,73 @@ class Bsd {
 
   static julong _physical_memory;
   static pthread_t _main_thread;
+#ifndef _ALLBSD_SOURCE
   static Mutex* _createThread_lock;
+#endif
   static int _page_size;
 
   static julong available_memory();
   static julong physical_memory() { return _physical_memory; }
   static void initialize_system_info();
 
+#ifndef _ALLBSD_SOURCE
   static void set_glibc_version(const char *s)      { _glibc_version = s; }
   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
+#endif
 
   static bool supports_variable_stack_size();
 
+#ifndef _ALLBSD_SOURCE
   static void set_is_NPTL()                   { _is_NPTL = true;  }
   static void set_is_BsdThreads()           { _is_NPTL = false; }
   static void set_is_floating_stack()         { _is_floating_stack = true; }
+#endif
 
   static void rebuild_cpu_to_node_map();
   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }
  public:
+#ifdef _ALLBSD_SOURCE
+//XXXBSD: ported from solaris version
+  enum {
+    clear_interrupted = true
+  };
+  static void setup_interruptible(JavaThread* thread);
+  static void setup_interruptible_already_blocked(JavaThread* thread);
+  static JavaThread* setup_interruptible();
+  static void cleanup_interruptible(JavaThread* thread);
+
+  // perf counter incrementers used by _INTERRUPTIBLE 
+
+  static void bump_interrupted_before_count();
+  static void bump_interrupted_during_count();
+
+#ifdef ASSERT
+  static JavaThread* setup_interruptible_native();
+  static void cleanup_interruptible_native(JavaThread* thread);
+#endif
+
+#endif
+
   static void init_thread_fpu_state();
+#ifndef _ALLBSD_SOURCE
   static int  get_fpu_control_word();
   static void set_fpu_control_word(int fpu_control);
+#endif
   static pthread_t main_thread(void)                                { return _main_thread; }
+
+#ifndef _ALLBSD_SOURCE
   // returns kernel thread id (similar to LWP id on Solaris), which can be
   // used to access /proc
   static pid_t gettid();
   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }
   static Mutex* createThread_lock(void)                             { return _createThread_lock; }
+#endif
   static void hotspot_sigmask(Thread* thread);
 
+#ifndef _ALLBSD_SOURCE
   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+#endif
   static bool is_initial_thread(void);
 
   static int page_size(void)                                        { return _page_size; }
@@ -133,6 +170,7 @@ class Bsd {
   static struct sigaction *get_chained_signal_action(int sig);
   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
 
+#ifndef _ALLBSD_SOURCE
   // GNU libc and libpthread version strings
   static const char *glibc_version()          { return _glibc_version; }
   static const char *libpthread_version()     { return _libpthread_version; }
@@ -146,6 +184,7 @@ class Bsd {
   static bool is_floating_stack()             { return _is_floating_stack; }
 
   static void libpthread_init();
+#endif
   static bool libnuma_init();
 
   // Minimum stack size a thread can be created with (allowing
@@ -156,17 +195,21 @@ class Bsd {
   static size_t default_stack_size(os::ThreadType thr_type);
   static size_t default_guard_size(os::ThreadType thr_type);
 
+#ifndef _ALLBSD_SOURCE
   static void capture_initial_stack(size_t max_size);
 
   // Stack overflow handling
   static bool manually_expand_stack(JavaThread * t, address addr);
   static int max_register_window_saves_before_flushing();
+#endif
 
   // Real-time clock functions
   static void clock_init(void);
 
+#ifndef _ALLBSD_SOURCE
   // fast POSIX clocks support
   static void fast_thread_clock_init(void);
+#endif
 
   static bool supports_monotonic_clock() {
     return _clock_gettime != NULL;
@@ -176,6 +219,7 @@ class Bsd {
     return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;
   }
 
+#ifndef _ALLBSD_SOURCE
   static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
     return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;
   }
@@ -185,6 +229,7 @@ class Bsd {
   }
 
   static jlong fast_thread_cpu_time(clockid_t clockid);
+#endif
 
   // Stack repair handling
 
