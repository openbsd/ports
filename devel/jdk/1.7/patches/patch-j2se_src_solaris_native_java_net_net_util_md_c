$OpenBSD: patch-j2se_src_solaris_native_java_net_net_util_md_c,v 1.1 2007/09/06 15:46:19 kurt Exp $
--- j2se/src/solaris/native/java/net/net_util_md.c.orig	Thu Jul  5 05:03:38 2007
+++ j2se/src/solaris/native/java/net/net_util_md.c	Fri Jul 27 18:25:14 2007
@@ -34,6 +34,11 @@
 #include <stdlib.h>
 #include <dlfcn.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -219,8 +224,16 @@ NET_GetFileDescriptorID(JNIEnv *env)
     return (*env)->GetFieldID(env, cls, "fd", "I");
 }
 
+#if defined(DONT_ENABLE_IPV6)
 jint  IPv6_supported()
 {
+    return JNI_FALSE;
+}
+
+#else /* !DONT_ENABLE_IPV6 */
+
+jint  IPv6_supported()
+{
 #ifndef AF_INET6
     return JNI_FALSE;
 #endif
@@ -355,6 +368,7 @@ jint  IPv6_supported()
     close(fd);
     return JNI_TRUE; 
 }
+#endif /* DONT_ENABLE_IPV6 */
 
 void 
 NET_AllocSockaddr(struct sockaddr **him, int *len) {
@@ -689,6 +703,10 @@ NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, 
 	him6->sin6_family = AF_INET6; 
 	*len = sizeof(struct sockaddr_in6) ;
 
+#if defined(_ALLBSD_SOURCE) && defined(_AF_INET6)
+// XXXBSD: should we do something with scope id here ? see below linux comment
+#endif
+
 	/*
  	 * On Linux if we are connecting to a link-local address
 	 * we need to specify the interface in the scope_id (2.4 kernel only)
@@ -1133,6 +1151,17 @@ NET_SetSockOpt(int fd, int level, int  opt, const void
 #define IPTOS_PREC_MASK 0xe0
 #endif
 
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+    int mib[3];
+    size_t rlen;
+    int *bufsize;
+
+    static long maxsockbuf = -1;
+
+    int addopt;
+    struct linger *ling;
+#endif
+
     /*
      * IPPROTO/IP_TOS :-
      * 1. IPv6 on Solaris: no-op and will be set in flowinfo
@@ -1165,6 +1194,10 @@ NET_SetSockOpt(int fd, int level, int  opt, const void
         *iptos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
     }
 
+#if defined(AF_INET6) && defined(_ALLBSD_SOURCE)
+// XXXBSD: to be implemented ?
+#endif
+
     /*
      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris need to
      * ensure that value is <= max_buf as otherwise we get
@@ -1203,12 +1236,87 @@ NET_SetSockOpt(int fd, int level, int  opt, const void
      * is that if SO_RCVBUF is too small then small packets
      * must be discard.
      */
-#ifdef __linux__
+#if defined(__linux__)
     if (level == SOL_SOCKET && opt == SO_RCVBUF) {
 	int *bufsize = (int *)arg;
 	if (*bufsize < 1024) {
 	    *bufsize = 1024;
 	}
+    }
+#endif
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+    /*
+     * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
+     * ensure that value is <= kern.ipc.maxsockbuf as otherwise we get
+     * an ENOBUFS error.
+     */
+    if (level == SOL_SOCKET) {
+        if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
+#ifdef KIPC_MAXSOCKBUF
+            if (maxsockbuf == -1) {
+               mib[0] = CTL_KERN;
+               mib[1] = KERN_IPC;
+               mib[2] = KIPC_MAXSOCKBUF;
+               rlen = sizeof(maxsockbuf);
+               if (sysctl(mib, 3, &maxsockbuf, &rlen, NULL, 0) == -1)
+                   maxsockbuf = 1024;
+
+#if 1
+               /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
+                  problem.  It should be removed when kern.ipc.maxsockbuf
+                  will be real value. */
+               maxsockbuf = (maxsockbuf/5)*4;
+#endif
+           }
+#else
+	   maxsockbuf = 64 * 1024;	/* XXX: NetBSD */
+#endif
+
+           bufsize = (int *)arg;
+           if (*bufsize > maxsockbuf) {
+               *bufsize = maxsockbuf;
+           }
+
+	   if (opt == SO_RCVBUF && *bufsize < 1024) {
+		*bufsize = 1024;
+	   }
+
+        }
+    }
+
+    /*
+     * On Solaris, SO_REUSEADDR will allow multiple datagram
+     * sockets to bind to the same port.  The network jck tests
+     * for this "feature", so we need to emulate it by turning on
+     * SO_REUSEPORT as well for that combination.
+     */
+    if (level == SOL_SOCKET && opt == SO_REUSEADDR) {
+        int sotype, arglen;
+
+        arglen = sizeof(sotype);
+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) < 0) {
+            return -1;
+        }
+
+        if (sotype == SOCK_DGRAM) {
+            addopt = SO_REUSEPORT;
+            setsockopt(fd, level, addopt, arg, len);
+        }
+    }
+
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
     }
 #endif
 
